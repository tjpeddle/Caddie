<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Voice Golf Caddie</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=JetBrains+Mono:wght@400;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'DM Sans', sans-serif;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .main-container {
            width: 100%;
            max-width: 500px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }
        
        /* Header */
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-top: 20px;
        }
        
        .header h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .header .subtitle {
            font-size: 0.9rem;
            opacity: 0.7;
            font-family: 'JetBrains Mono', monospace;
        }
        
        /* Voice Interface - Main Focus */
        .voice-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 30px;
        }
        
        .voice-orb {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #4ade80, #22c55e);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 20px 60px rgba(74, 222, 128, 0.4);
            position: relative;
        }
        
        .voice-orb::before {
            content: '';
            position: absolute;
            width: 220px;
            height: 220px;
            border-radius: 50%;
            border: 2px solid rgba(74, 222, 128, 0.3);
            animation: pulse-ring 2s infinite;
        }
        
        @keyframes pulse-ring {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.5;
            }
        }
        
        .voice-orb.listening {
            animation: listening-pulse 1s infinite;
            background: radial-gradient(circle at 30% 30%, #ef4444, #dc2626);
            box-shadow: 0 20px 60px rgba(239, 68, 68, 0.6);
        }
        
        @keyframes listening-pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }
        
        .voice-orb:active {
            transform: scale(0.95);
        }
        
        .voice-icon {
            font-size: 4rem;
        }
        
        .conversation {
            width: 100%;
            text-align: center;
            min-height: 80px;
            max-height: 200px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow: hidden;
        }
        
        .caddie-speaks {
            font-size: 1.1rem;
            line-height: 1.6;
            font-weight: 500;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-height: 150px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .you-said {
            font-size: 0.9rem;
            opacity: 0.6;
            font-family: 'JetBrains Mono', monospace;
            flex-shrink: 0;
        }
        
        /* Quick Info (hidden - data tracked internally) */
        
        /* Bottom Actions */
        .bottom-actions {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            padding-bottom: 20px;
        }
        
        .action-btn {
            padding: 14px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: white;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .action-btn:active {
            transform: scale(0.95);
            background: rgba(74, 222, 128, 0.3);
        }
        
        /* Welcome Screen */
        .welcome-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 40px;
        }
        
        .welcome-content {
            text-align: center;
            max-width: 400px;
        }
        
        .welcome-content h1 {
            font-size: 3rem;
            margin-bottom: 16px;
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .welcome-content p {
            font-size: 1.1rem;
            line-height: 1.8;
            opacity: 0.8;
            margin-bottom: 40px;
        }
        
        .start-btn {
            padding: 20px 40px;
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            border: none;
            border-radius: 50px;
            font-size: 1.2rem;
            font-weight: 700;
            color: #0f2027;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 10px 30px rgba(74, 222, 128, 0.4);
        }
        
        .start-btn:active {
            transform: scale(0.95);
        }
        
        .hidden {
            display: none;
        }
        
        /* Setup Mode */
        .setup-mode {
            display: none;
            text-align: center;
        }
        
        .setup-mode.active {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .setup-prompt {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <!-- Welcome Screen -->
    <div class="welcome-screen" id="welcomeScreen">
        <div class="welcome-content">
            <h1>‚õ≥ Voice Caddie</h1>
            <p>
                Put your phone in your bag.<br>
                Talk to me like a real caddie.<br>
                I'll help you play your best.
            </p>
            <button class="start-btn" id="startBtn">Let's Go</button>
        </div>
    </div>

    <!-- Main App -->
    <div class="main-container" id="mainApp" style="display: none;">
        
        <!-- Header -->
        <div class="header">
            <h1>‚õ≥ CADDIE</h1>
            <div class="subtitle" id="courseInfo">Ready when you are</div>
        </div>
        
        <!-- Hidden data holders (AI tracks these, no visual display needed) -->
        <div style="display:none;">
            <span id="currentHole">--</span>
            <span id="distanceDisplay">--</span>
            <span id="scoreDisplay">0</span>
        </div>
        
        <!-- Voice Interface -->
        <div class="voice-section">
            <button class="voice-orb" id="voiceOrb">
                <span class="voice-icon">üé§</span>
            </button>
            
            <div class="conversation">
                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 8px; color: #4ade80;" id="voiceStatus">
                    Tap mic to start
                </div>
                <div class="caddie-speaks" id="caddieMessage">
                    Ready to talk golf
                </div>
                <div class="you-said" id="yourMessage"></div>
                
                <!-- Simplified help -->
                <div style="font-size: 0.7rem; opacity: 0.5; margin-top: 10px; text-align: center;">
                    Tap mic = mute/unmute (like your Shokz button)
                </div>
            </div>
        </div>
        
        <!-- Bottom Actions -->
        <div class="bottom-actions" style="grid-template-columns: repeat(2, 1fr);">
            <button class="action-btn" id="statsBtn">üìà My Game</button>
            <button class="action-btn" id="historyBtn">üèåÔ∏è History</button>
        </div>
        
    </div>

    <script>
        // ==========================================
        // KEEP APP ALIVE & BLUETOOTH AUDIO LOCK
        // ==========================================
        
        class KeepAlive {
            constructor() {
                this.wakeLock = null;
                this.silentAudio = null;
                this.noSleepVideo = null;
            }
            
            async start() {
                // 1. Wake Lock API ‚Äî prevents screen from sleeping
                await this.requestWakeLock();
                
                // Re-acquire wake lock when page becomes visible again
                document.addEventListener('visibilitychange', async () => {
                    if (document.visibilityState === 'visible') {
                        await this.requestWakeLock();
                        this.ensureSilentAudio();
                    }
                });
                
                // 2. Silent audio loop ‚Äî keeps Bluetooth audio route active
                this.startSilentAudio();
                
                // 3. NoSleep video trick ‚Äî iOS fallback to prevent sleep
                this.startNoSleepVideo();
                
                console.log('üîí Keep-alive systems active');
            }
            
            async requestWakeLock() {
                try {
                    if ('wakeLock' in navigator) {
                        this.wakeLock = await navigator.wakeLock.request('screen');
                        this.wakeLock.addEventListener('release', () => {
                            console.log('‚ö†Ô∏è Wake lock released');
                        });
                        console.log('‚úÖ Wake lock acquired');
                    }
                } catch (err) {
                    console.log('Wake lock not available:', err.message);
                }
            }
            
            startSilentAudio() {
                try {
                    // Create AudioContext to hold Bluetooth route
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    const ctx = new AudioContext();
                    
                    // Create a silent oscillator
                    const oscillator = ctx.createOscillator();
                    const gain = ctx.createGain();
                    gain.gain.value = 0.001; // Nearly silent
                    oscillator.connect(gain);
                    gain.connect(ctx.destination);
                    oscillator.start();
                    
                    this.silentAudio = { ctx, oscillator, gain };
                    console.log('‚úÖ Silent audio loop active (Bluetooth lock)');
                } catch (err) {
                    console.log('Silent audio fallback:', err.message);
                }
            }
            
            ensureSilentAudio() {
                if (this.silentAudio?.ctx?.state === 'suspended') {
                    this.silentAudio.ctx.resume();
                    console.log('üîÑ Resumed silent audio');
                }
            }
            
            startNoSleepVideo() {
                try {
                    // Tiny looping video keeps iOS awake
                    const video = document.createElement('video');
                    video.setAttribute('playsinline', '');
                    video.setAttribute('muted', '');
                    video.setAttribute('loop', '');
                    video.style.position = 'fixed';
                    video.style.top = '-1px';
                    video.style.left = '-1px';
                    video.style.width = '1px';
                    video.style.height = '1px';
                    video.style.opacity = '0.01';
                    
                    // Minimal base64 mp4 (tiny silent video)
                    video.src = 'data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAA' +
                        'NBtZGF0AAACrgYF//+q3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0OCByMjYwMSBhMGNkN2' +
                        'QzIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNSAtIGh0dHA6Ly9' +
                        '3d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTMgZGVibG9j';
                    
                    document.body.appendChild(video);
                    
                    // Play on user interaction
                    const playVideo = () => {
                        video.play().catch(() => {});
                    };
                    document.addEventListener('click', playVideo, { once: true });
                    document.addEventListener('touchstart', playVideo, { once: true });
                    
                    this.noSleepVideo = video;
                    console.log('‚úÖ NoSleep video ready');
                } catch (err) {
                    console.log('NoSleep video fallback:', err.message);
                }
            }
            
            stop() {
                if (this.wakeLock) this.wakeLock.release();
                if (this.silentAudio) {
                    this.silentAudio.oscillator.stop();
                    this.silentAudio.ctx.close();
                }
                if (this.noSleepVideo) this.noSleepVideo.remove();
            }
        }
        
        // ==========================================
        // CLAUDE AI INTEGRATION
        // ==========================================
        
        class ClaudeAI {
            constructor() {
                // API key is handled server-side by Vercel proxy ‚Äî no key needed here!
                this.endpoint = 'https://caddie-proxy.vercel.app/api/chat';
                this.conversationHistory = [];
                this.memory = this.loadMemory();
                this.messageCount = 0;
            }

            hasValidKey() {
                return true; // Always valid ‚Äî proxy handles the key
            }

            setApiKey(key) {
                // No-op ‚Äî proxy handles the key
                console.log('‚úÖ API key handled by server proxy');
            }

            clearApiKey() {
                // No-op ‚Äî proxy handles the key
            }
            
            // ==========================================
            // PERSISTENT MEMORY SYSTEM
            // Survives app closes, swipe-outs, restarts
            // ==========================================
            
            loadMemory() {
                try {
                    const stored = localStorage.getItem('caddie_ai_memory');
                    return stored ? JSON.parse(stored) : this.getDefaultMemory();
                } catch (e) {
                    return this.getDefaultMemory();
                }
            }
            
            getDefaultMemory() {
                return {
                    playerNotes: [],      // AI observations about the player
                    swingTips: [],         // Tips discussed
                    tendencies: [],        // Patterns noticed (e.g. "slices driver")
                    roundSummaries: [],    // End-of-round AI summaries
                    preferences: [],       // Player preferences (e.g. "aggressive putter")
                    lastUpdated: null
                };
            }
            
            saveMemory() {
                try {
                    this.memory.lastUpdated = new Date().toISOString();
                    localStorage.setItem('caddie_ai_memory', JSON.stringify(this.memory));
                    console.log('üíæ AI memory saved');
                } catch (e) {
                    console.error('Memory save error:', e);
                }
            }
            
            addMemoryNote(category, note) {
                if (!this.memory[category]) return;
                // Keep last 20 notes per category
                this.memory[category].push({
                    note,
                    date: new Date().toISOString()
                });
                if (this.memory[category].length > 20) {
                    this.memory[category] = this.memory[category].slice(-20);
                }
                this.saveMemory();
            }
            
            getMemoryContext() {
                let memoryStr = '';
                
                if (this.memory.playerNotes.length > 0) {
                    const recentNotes = this.memory.playerNotes.slice(-5).map(n => n.note).join('; ');
                    memoryStr += `\n\nPlayer Notes from previous sessions: ${recentNotes}`;
                }
                
                if (this.memory.tendencies.length > 0) {
                    const tendencies = this.memory.tendencies.slice(-5).map(n => n.note).join('; ');
                    memoryStr += `\nPlayer tendencies: ${tendencies}`;
                }
                
                if (this.memory.swingTips.length > 0) {
                    const tips = this.memory.swingTips.slice(-3).map(n => n.note).join('; ');
                    memoryStr += `\nRecent tips discussed: ${tips}`;
                }
                
                if (this.memory.roundSummaries.length > 0) {
                    const lastRound = this.memory.roundSummaries.slice(-1)[0];
                    memoryStr += `\nLast round summary: ${lastRound.note}`;
                }
                
                if (this.memory.preferences.length > 0) {
                    const prefs = this.memory.preferences.slice(-5).map(n => n.note).join('; ');
                    memoryStr += `\nPlayer preferences: ${prefs}`;
                }
                
                return memoryStr;
            }
            
            async generateMemoryUpdate(conversationSlice) {
                // Every 10 messages, ask AI to extract key notes
                try {
                    const response = await fetch(this.endpoint, {
                        method: 'POST',
                        headers: { 'content-type': 'application/json' },
                        body: JSON.stringify({
                            model: 'claude-haiku-4-5-20251001',
                            max_tokens: 300,
                            system: `Extract key golf notes about this player from the conversation. Return ONLY a JSON object with these arrays (each item is a short string):
{"playerNotes": ["note1"], "tendencies": ["tendency1"], "swingTips": ["tip1"], "preferences": ["pref1"]}
Only include categories that have new info. Keep notes brief (under 15 words each).`,
                            messages: [{
                                role: 'user',
                                content: `Conversation to analyze:\n${conversationSlice.map(m => `${m.role}: ${m.content}`).join('\n')}`
                            }]
                        })
                    });
                    
                    const data = await response.json();
                    const text = data.content?.[0]?.text || '';
                    
                    // Parse AI response
                    const jsonMatch = text.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        const notes = JSON.parse(jsonMatch[0]);
                        for (const [category, items] of Object.entries(notes)) {
                            if (Array.isArray(items) && this.memory[category]) {
                                items.forEach(note => this.addMemoryNote(category, note));
                            }
                        }
                        console.log('üß† Memory updated from conversation');
                    }
                } catch (e) {
                    console.log('Memory update skipped:', e.message);
                }
            }
            
            async generateRoundSummary(roundData) {
                try {
                    const response = await fetch(this.endpoint, {
                        method: 'POST',
                        headers: { 'content-type': 'application/json' },
                        body: JSON.stringify({
                            model: 'claude-haiku-4-5-20251001',
                            max_tokens: 200,
                            system: 'Summarize this golf round in 2-3 sentences. Focus on what went well, what to improve, and key stats. Be specific.',
                            messages: [{
                                role: 'user',
                                content: `Round data: ${JSON.stringify(roundData)}\nConversation highlights: ${this.conversationHistory.slice(-6).map(m => `${m.role}: ${m.content}`).join('\n')}`
                            }]
                        })
                    });
                    
                    const data = await response.json();
                    const summary = data.content?.[0]?.text || '';
                    if (summary) {
                        this.addMemoryNote('roundSummaries', summary);
                        console.log('üìù Round summary saved');
                    }
                } catch (e) {
                    console.log('Round summary skipped:', e.message);
                }
            }

            async ask(userMessage, context = {}) {
                console.log('ü§ñ Asking Claude AI:', userMessage);
                
                // Build system context from game state + memory
                const systemContext = this.buildContext(context) + this.getMemoryContext();
                
                // Add user message to conversation
                this.conversationHistory.push({
                    role: 'user',
                    content: userMessage
                });
                
                this.messageCount++;
                
                try {
                    const response = await fetch(this.endpoint, {
                        method: 'POST',
                        headers: {
                            'content-type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: 'claude-haiku-4-5-20251001',
                            max_tokens: 300,
                            system: systemContext,
                            messages: this.conversationHistory.slice(-10)
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('API Error Response:', errorText);
                        throw new Error(`API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('‚úÖ Claude AI responded');
                    
                    // Extract text response
                    let aiResponse = '';
                    for (const block of data.content) {
                        if (block.type === 'text') {
                            aiResponse += block.text;
                        }
                    }
                    
                    // Add to conversation history
                    this.conversationHistory.push({
                        role: 'assistant',
                        content: aiResponse
                    });
                    
                    // Every 10 messages, save memory in background
                    if (this.messageCount % 10 === 0) {
                        this.generateMemoryUpdate(this.conversationHistory.slice(-10));
                    }
                    
                    return aiResponse;
                    
                } catch (error) {
                    console.error('‚ùå Claude API Error:', error);
                    
                    let errMsg = '';
                    if (error.message.includes('401')) {
                        errMsg = "API key issue. Check your Vercel settings.";
                    } else if (error.message.includes('429')) {
                        errMsg = "Rate limit hit. Give me a sec and try again.";
                    } else {
                        errMsg = "Having trouble connecting. Check your signal.";
                    }
                    
                    return errMsg;
                }
            }

            buildContext(context) {
                const { 
                    currentHole, 
                    distance, 
                    score, 
                    course,
                    holesPlayed,
                    clubHistory,
                    conditions
                } = context;
                
                let systemPrompt = `You are an expert golf caddie having a natural conversation with your player. You're walking the course together on a REAL golf course RIGHT NOW. Your style:
- Talk like a real caddie: casual, confident, supportive, like a buddy
- Keep responses SHORT (1-3 sentences max) unless they ask you to explain something
- You know Vector Putting (Zero Break Line, Gravity Vectors, slope %, stimp, aim points)
- You know golf strategy, course management, club selection, mental game
- Give SPECIFIC advice based on their actual club distances below ‚Äî never guess
- Remember everything they tell you in this conversation
- When they tell you club distances, acknowledge and remember them
- When they ask about a club, reference the distances below
- Be encouraging but honest ‚Äî if they're struggling, help them refocus

IMPORTANT: The game state below comes from REAL GPS and real tracking on the player's phone. The distances, hole numbers, and scores are REAL ‚Äî trust them completely. You DO know where they are. If you see a distance, it's their actual distance. Never say you don't know their location or can't see them ‚Äî you have their live data.

Current Game State:`;

                if (course) systemPrompt += `\n- Course: ${course} (REAL course, playing right now)`;
                if (currentHole) {
                    systemPrompt += `\n- Hole ${currentHole.number}, Par ${currentHole.par || 4}, Position: ${currentHole.state || 'tee'}`;
                    if (currentHole.shots?.length > 0) {
                        const clubs = currentHole.shots.map(s => s.club).join(', ');
                        systemPrompt += `\n- Shots this hole: ${clubs} (${currentHole.shots.length} shots)`;
                    }
                }
                if (distance) systemPrompt += `\n- GPS Distance to pin: ${distance} yards (REAL measurement)`;
                else systemPrompt += `\n- Distance to pin: unknown (ask the player how far they are)`;
                if (score !== undefined && holesPlayed) {
                    const par = holesPlayed * 4;
                    const diff = score - par;
                    systemPrompt += `\n- Score: ${score} (${diff >= 0 ? '+' + diff : diff} through ${holesPlayed})`;
                }
                if (conditions?.windy) systemPrompt += `\n- Wind present`;
                
                // ALWAYS include full club bag
                if (context.playerClubs) {
                    const clubs = context.playerClubs;
                    systemPrompt += `\n\nPlayer's Club Distances (MEMORIZE THESE):`;
                    for (const [club, dist] of Object.entries(clubs)) {
                        systemPrompt += `\n  ${club}: ${dist} yards`;
                    }
                }
                
                if (!course && !currentHole) {
                    systemPrompt += `\n\nNo round started yet. Help them get set up ‚Äî ask what course and what hole they're starting on. If they want to set up clubs, walk them through it naturally.`;
                }

                return systemPrompt;
            }

            resetConversation() {
                this.conversationHistory = [];
                console.log('üîÑ AI conversation reset');
            }
        }

        // Vector Putting Calculation Engine
        class VectorPuttingCalculator {
            constructor() {
                // Gravity Vector Tables based on green speed (Stimpmeter reading)
                // Values are in inches for different distances and slopes
                this.gravityVectorTables = {
                    // Slow greens (Stimp 6-7)
                    'slow': {
                        '1%': { 5: 1, 10: 3, 15: 5, 20: 8, 25: 11, 30: 15 },
                        '2%': { 5: 2, 10: 6, 15: 10, 20: 15, 25: 21, 30: 29 },
                        '3%': { 5: 3, 10: 9, 15: 16, 20: 24, 25: 33, 30: 44 },
                        '4%': { 5: 4, 10: 12, 15: 21, 20: 32, 25: 44, 30: 58 },
                        '5%': { 5: 5, 10: 15, 15: 27, 20: 40, 25: 55, 30: 73 }
                    },
                    // Medium greens (Stimp 7.5-8.5)
                    'medium': {
                        '1%': { 5: 1, 10: 4, 15: 7, 20: 10, 25: 14, 30: 19 },
                        '2%': { 5: 3, 10: 7, 15: 13, 20: 20, 25: 28, 30: 37 },
                        '3%': { 5: 4, 10: 10, 15: 19, 20: 29, 25: 41, 30: 55 },
                        '4%': { 5: 5, 10: 14, 15: 26, 20: 39, 25: 55, 30: 73 },
                        '5%': { 5: 6, 10: 18, 15: 32, 20: 49, 25: 69, 30: 92 }
                    },
                    // Fast greens (Stimp 9-10)
                    'fast': {
                        '1%': { 5: 2, 10: 5, 15: 9, 20: 13, 25: 18, 30: 24 },
                        '2%': { 5: 3, 10: 9, 15: 17, 20: 26, 25: 36, 30: 48 },
                        '3%': { 5: 5, 10: 14, 15: 25, 20: 38, 25: 53, 30: 71 },
                        '4%': { 5: 7, 10: 18, 15: 33, 20: 51, 25: 71, 30: 95 },
                        '5%': { 5: 8, 10: 23, 15: 42, 20: 64, 25: 89, 30: 119 }
                    },
                    // Very fast greens (Stimp 10.5-12)
                    'veryfast': {
                        '1%': { 5: 2, 10: 6, 15: 11, 20: 16, 25: 23, 30: 30 },
                        '2%': { 5: 4, 10: 11, 15: 21, 20: 32, 25: 45, 30: 60 },
                        '3%': { 5: 6, 10: 17, 15: 31, 20: 48, 25: 67, 30: 89 },
                        '4%': { 5: 8, 10: 23, 15: 42, 20: 64, 25: 89, 30: 119 },
                        '5%': { 5: 10, 10: 29, 15: 53, 20: 80, 25: 111, 30: 149 }
                    }
                };
            }

            getGreenSpeedCategory(stimp) {
                if (stimp < 7.5) return 'slow';
                if (stimp < 9) return 'medium';
                if (stimp < 10.5) return 'fast';
                return 'veryfast';
            }

            calculateGravityVector(distance, slope, stimp) {
                const speedCat = this.getGreenSpeedCategory(stimp);
                const slopeKey = `${Math.round(slope)}%`;
                
                // Round distance to nearest 5 feet
                const distKey = Math.round(distance / 5) * 5;
                const clampedDist = Math.max(5, Math.min(30, distKey));
                
                const table = this.gravityVectorTables[speedCat];
                if (!table[slopeKey]) {
                    // Interpolate if exact slope not in table
                    const nearestSlope = Math.min(5, Math.max(1, Math.round(slope)));
                    return table[`${nearestSlope}%`][clampedDist] || 10;
                }
                
                return table[slopeKey][clampedDist] || 10;
            }

            getAimPoint(distance, slope, stimp, breakDirection, uphillDownhill = 'level') {
                const gravityVector = this.calculateGravityVector(distance, slope, stimp);
                
                // Adjust for uphill/downhill (elastic gravity vector)
                let adjustedVector = gravityVector;
                if (uphillDownhill === 'uphill') {
                    adjustedVector = Math.round(gravityVector * 0.85); // Reduce by 15%
                } else if (uphillDownhill === 'downhill') {
                    adjustedVector = Math.round(gravityVector * 1.15); // Increase by 15%
                }
                
                // Build the aim instruction
                let aimDirection = '';
                if (breakDirection === 'left-to-right' || breakDirection === 'left to right') {
                    aimDirection = 'left';
                } else if (breakDirection === 'right-to-left' || breakDirection === 'right to left') {
                    aimDirection = 'right';
                }
                
                return {
                    inches: adjustedVector,
                    direction: aimDirection,
                    description: this.buildAimDescription(adjustedVector, aimDirection, distance)
                };
            }

            buildAimDescription(inches, direction, distance) {
                if (inches < 2) {
                    return "Aim at the center of the cup";
                } else if (inches <= 4) {
                    return `Aim at the ${direction} edge of the cup`;
                } else if (inches <= 12) {
                    return `Aim ${inches} inches ${direction} of center - about ${Math.round(inches / 4.25 * 10) / 10} cup widths`;
                } else {
                    const feet = Math.floor(inches / 12);
                    const remainingInches = inches % 12;
                    if (remainingInches === 0) {
                        return `Aim ${feet} foot ${direction} of the hole`;
                    } else {
                        return `Aim ${feet} feet ${remainingInches} inches ${direction} of the hole`;
                    }
                }
            }
        }

        // Storage
        class CaddieStorage {
            constructor() {
                this.key = 'voice_caddie_v2';
                this.data = this.load();
            }

            load() {
                try {
                    const stored = localStorage.getItem(this.key);
                    return stored ? JSON.parse(stored) : this.getDefault();
                } catch (e) {
                    return this.getDefault();
                }
            }

            getDefault() {
                return {
                    profile: {
                        courses: [],
                        clubDistances: this.getDefaultClubs(),
                        voiceSpeed: 1.0 // Default normal speed (0.5 = slow, 2.0 = fast)
                    },
                    rounds: [],
                    currentRound: null,
                    stats: {
                        totalRounds: 0,
                        totalShots: 0
                    }
                };
            }

            getDefaultClubs() {
                return {
                    'Driver': 250, '3 Wood': 220, '5 Wood': 200, 'Hybrid': 190,
                    '3 Iron': 200, '4 Iron': 185, '5 Iron': 170, '6 Iron': 160,
                    '7 Iron': 150, '8 Iron': 140, '9 Iron': 130,
                    'Pitching Wedge': 120, 'Gap Wedge': 100, 'Sand Wedge': 80, 'Lob Wedge': 60
                };
            }

            save() {
                localStorage.setItem(this.key, JSON.stringify(this.data));
            }

            startRound(courseName, holeNumber) {
                this.data.currentRound = {
                    course: courseName,
                    date: new Date().toISOString(),
                    currentHole: {
                        number: holeNumber,
                        par: this.estimatePar(null),
                        shots: [],
                        state: 'tee'
                    },
                    holes: [],
                    score: 0
                };
                
                if (!this.data.profile.courses.includes(courseName)) {
                    this.data.profile.courses.push(courseName);
                }
                
                this.save();
            }

            recordShot(club, distance, context = {}) {
                if (!this.data.currentRound) return;
                
                const shot = {
                    club,
                    distance,
                    timestamp: new Date().toISOString(),
                    course: this.data.currentRound.course,
                    hole: this.data.currentRound.currentHole.number,
                    ...context
                };
                
                this.data.currentRound.currentHole.shots.push(shot);
                this.data.stats.totalShots++;
                this.save();
                
                // Track club performance
                this.updateClubStats(club, context);
            }

            updateClubStats(club, context) {
                if (!this.data.clubPerformance) {
                    this.data.clubPerformance = {};
                }
                
                if (!this.data.clubPerformance[club]) {
                    this.data.clubPerformance[club] = {
                        totalUses: 0,
                        distances: [],
                        results: { green: 0, miss: 0 },
                        conditions: { wind: 0, noWind: 0 }
                    };
                }
                
                const stats = this.data.clubPerformance[club];
                stats.totalUses++;
                
                if (context.distance) {
                    stats.distances.push(context.distance);
                }
                
                if (context.hitGreen) {
                    stats.results.green++;
                } else if (context.hitGreen === false) {
                    stats.results.miss++;
                }
                
                if (context.windy) {
                    stats.conditions.wind++;
                } else {
                    stats.conditions.noWind++;
                }
                
                this.save();
            }

            getClubHistory(club) {
                return this.data.clubPerformance?.[club] || null;
            }

            getCourseHistory(courseName) {
                const rounds = this.data.rounds.filter(r => 
                    r.course.toLowerCase().includes(courseName.toLowerCase())
                );
                
                if (rounds.length === 0) return null;
                
                const holeStats = {};
                rounds.forEach(round => {
                    round.holes?.forEach(hole => {
                        const key = hole.number;
                        if (!holeStats[key]) {
                            holeStats[key] = {
                                scores: [],
                                clubs: []
                            };
                        }
                        holeStats[key].scores.push(hole.finalScore || 0);
                        hole.shots?.forEach(shot => {
                            holeStats[key].clubs.push(shot.club);
                        });
                    });
                });
                
                return {
                    timesPlayed: rounds.length,
                    lastPlayed: rounds[rounds.length - 1].date,
                    holeStats
                };
            }

            getSmartRecommendation(distance, conditions = {}) {
                const baseClub = this.recommendClub(distance);
                
                // AI LEARNING SYSTEM
                const clubHistory = this.getClubHistory(baseClub);
                if (!clubHistory || clubHistory.totalUses < 3) {
                    return { club: baseClub, reason: "standard distance" };
                }
                
                // Calculate actual average distance with this club
                const avgDistance = clubHistory.distances.reduce((a, b) => a + b, 0) / clubHistory.distances.length;
                
                // Calculate variance to understand consistency
                const variance = clubHistory.distances.reduce((sum, d) => sum + Math.pow(d - avgDistance, 2), 0) / clubHistory.distances.length;
                const stdDev = Math.sqrt(variance);
                
                // AI Pattern Recognition: Learn player tendencies
                const playerTendency = this.analyzeTendency(baseClub, avgDistance, this.data.profile.clubDistances[baseClub]);
                
                // Wind pattern learning
                let windAdjustment = 0;
                if (conditions.windy && clubHistory.conditions.wind > 2) {
                    // AI learns how much wind affects THIS player
                    const windShots = clubHistory.distances.filter((_, i) => 
                        this.data.shots?.[i]?.windy === true
                    );
                    if (windShots.length > 0) {
                        const windAvg = windShots.reduce((a, b) => a + b, 0) / windShots.length;
                        windAdjustment = avgDistance - windAvg;
                    } else {
                        windAdjustment = avgDistance * 0.1; // Default 10% loss
                    }
                }
                
                // AI Decision: Should we club up/down?
                let recommendation = baseClub;
                let reason = "";
                
                const effectiveDistance = avgDistance - windAdjustment;
                const targetDistance = distance;
                const gap = targetDistance - effectiveDistance;
                
                // High variance = inconsistent, be conservative
                const consistencyFactor = stdDev > 10 ? 1.2 : 1.0;
                
                if (Math.abs(gap) > 5 * consistencyFactor) {
                    const clubs = Object.keys(this.data.profile.clubDistances);
                    const currentIndex = clubs.findIndex(c => c === baseClub);
                    
                    if (gap > 5) {
                        // Need more club
                        if (currentIndex > 0) {
                            recommendation = clubs[currentIndex - 1];
                            reason = conditions.windy 
                                ? `club up for wind - you lose ${Math.round(windAdjustment)} yards in wind`
                                : `your ${baseClub} averages ${Math.round(avgDistance)}, need more club`;
                        }
                    } else if (gap < -5) {
                        // Need less club
                        if (currentIndex < clubs.length - 1) {
                            recommendation = clubs[currentIndex + 1];
                            reason = `your ${baseClub} averages ${Math.round(avgDistance)}, that's too much`;
                        }
                    }
                }
                
                // AI Insight: Consistency warning
                if (!reason && stdDev > 15) {
                    reason = `you're inconsistent with ${baseClub} - varies ${Math.round(stdDev)} yards`;
                } else if (!reason && stdDev < 8) {
                    reason = `you're dialed in with ${baseClub}`;
                } else if (!reason) {
                    reason = `${baseClub} averages ${Math.round(avgDistance)} for you`;
                }
                
                return { club: recommendation, reason, confidence: this.calculateConfidence(clubHistory, stdDev) };
            }

            analyzeTendency(club, avgActual, baseline) {
                const diff = avgActual - baseline;
                if (Math.abs(diff) < 3) return 'accurate';
                if (diff > 0) return 'long';
                return 'short';
            }

            calculateConfidence(history, stdDev) {
                // AI confidence score based on data quality
                const sampleSize = history.totalUses;
                const consistencyScore = Math.max(0, 100 - stdDev * 5);
                const dataScore = Math.min(100, sampleSize * 10);
                return Math.round((consistencyScore + dataScore) / 2);
            }

            // AI Predictive Analytics: Course-specific patterns
            getCourseInsights(courseName, holeNumber) {
                const history = this.getCourseHistory(courseName);
                if (!history || !history.holeStats[holeNumber]) return null;
                
                const holeData = history.holeStats[holeNumber];
                const scores = holeData.scores;
                const clubs = holeData.clubs;
                
                // AI Pattern Detection
                const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
                const bestScore = Math.min(...scores);
                const worstScore = Math.max(...scores);
                
                // Find most successful club on this hole
                const clubFrequency = {};
                clubs.forEach(club => {
                    clubFrequency[club] = (clubFrequency[club] || 0) + 1;
                });
                const mostUsedClub = Object.entries(clubFrequency)
                    .sort((a, b) => b[1] - a[1])[0]?.[0];
                
                // AI Insight Generation
                return {
                    avgScore: Math.round(avgScore * 10) / 10,
                    bestScore,
                    worstScore,
                    mostUsedClub,
                    timesPlayed: scores.length,
                    trend: this.detectTrend(scores)
                };
            }

            detectTrend(scores) {
                if (scores.length < 3) return 'insufficient data';
                const recent = scores.slice(-3);
                const earlier = scores.slice(0, -3);
                if (earlier.length === 0) return 'improving';
                
                const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
                const earlierAvg = earlier.reduce((a, b) => a + b, 0) / earlier.length;
                
                if (recentAvg < earlierAvg - 0.5) return 'improving';
                if (recentAvg > earlierAvg + 0.5) return 'struggling';
                return 'consistent';
            }

            // AI Performance Tracking
            getPerformanceInsights() {
                const insights = [];
                
                // Analyze each club's performance
                Object.entries(this.data.clubPerformance || {}).forEach(([club, stats]) => {
                    if (stats.totalUses < 5) return;
                    
                    const avgDist = stats.distances.reduce((a, b) => a + b, 0) / stats.distances.length;
                    const baseline = this.data.profile.clubDistances[club];
                    const diff = avgDist - baseline;
                    
                    // Green hit rate
                    const total = stats.results.green + stats.results.miss;
                    const girRate = total > 0 ? (stats.results.green / total * 100) : 0;
                    
                    if (Math.abs(diff) > 8) {
                        insights.push({
                            type: 'distance_gap',
                            club,
                            message: `Your ${club} goes ${Math.round(avgDist)} yards, not ${baseline}. Update your baseline.`,
                            priority: 'high'
                        });
                    }
                    
                    if (girRate < 40 && total > 5) {
                        insights.push({
                            type: 'accuracy',
                            club,
                            message: `You're only hitting ${Math.round(girRate)}% of greens with ${club}. Practice needed.`,
                            priority: 'medium'
                        });
                    }
                    
                    if (girRate > 70 && total > 5) {
                        insights.push({
                            type: 'strength',
                            club,
                            message: `${club} is money! ${Math.round(girRate)}% greens hit.`,
                            priority: 'low'
                        });
                    }
                });
                
                return insights.sort((a, b) => {
                    const priority = { high: 3, medium: 2, low: 1 };
                    return priority[b.priority] - priority[a.priority];
                });
            }

            completeHole(score) {
                if (!this.data.currentRound) return;
                
                this.data.currentRound.currentHole.finalScore = score;
                this.data.currentRound.holes.push({...this.data.currentRound.currentHole});
                this.data.currentRound.score += score;
                this.save();
            }

            nextHole() {
                if (!this.data.currentRound) return;
                
                const nextNum = parseInt(this.data.currentRound.currentHole.number) + 1;
                this.data.currentRound.currentHole = {
                    number: nextNum,
                    par: this.estimatePar(null),
                    shots: [],
                    state: 'tee'
                };
                this.save();
            }

            estimatePar(distance) {
                if (!distance) return 4;
                if (distance > 350) return 5;
                if (distance < 200) return 3;
                return 4;
            }

            getCurrentHole() {
                return this.data.currentRound?.currentHole;
            }

            recommendClub(distance) {
                const clubs = this.data.profile.clubDistances;
                let bestClub = 'Lob Wedge';
                let minDiff = 999;

                for (let club in clubs) {
                    const diff = clubs[club] - distance;
                    if (diff >= -10 && diff < minDiff) {
                        bestClub = club;
                        minDiff = diff;
                    }
                }

                return bestClub;
            }
        }

        // Voice Interface
        class VoiceCaddie {
            constructor() {
                this.recognition = null;
                this.synthesis = window.speechSynthesis;
                this.isListening = false;
                this.continuousMode = false;
                this.isSpeaking = false;
                this.setupRecognition();
                
                // Fix for iOS - load voices
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.onvoiceschanged = () => {
                        this.voices = window.speechSynthesis.getVoices();
                    };
                }
            }

            setupRecognition() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (SpeechRecognition) {
                    this.recognition = new SpeechRecognition();
                    this.recognition.continuous = true; // Continuous listening
                    this.recognition.interimResults = false;
                    this.recognition.lang = 'en-US';
                    this.recognition.maxAlternatives = 1;
                }
            }

            async speak(text, customRate = null) {
                console.log('üó£Ô∏è Caddie speaking:', text);
                document.getElementById('caddieMessage').textContent = text;
                
                // Set speaking flag BEFORE any async operations
                this.isSpeaking = true;
                
                return new Promise((resolve) => {
                    // Cancel any ongoing speech
                    if (this.synthesis.speaking) {
                        this.synthesis.cancel();
                    }
                    
                    // Small delay for iOS
                    setTimeout(() => {
                        const utterance = new SpeechSynthesisUtterance(text);
                        
                        // Use custom rate or get from storage
                        const savedRate = window.app?.storage?.data?.profile?.voiceSpeed || 1.0;
                        utterance.rate = customRate || savedRate;
                        utterance.pitch = 0.95; // Slightly lower pitch sounds more natural
                        utterance.volume = 1;
                        
                        // Pick the best available voice on iOS
                        const voices = window.speechSynthesis.getVoices();
                        // Prefer enhanced/premium voices (Samantha, Aaron, etc.)
                        const preferredNames = ['Samantha', 'Aaron', 'Nicky', 'Alex', 'Daniel', 'Karen'];
                        let bestVoice = null;
                        
                        // First try: find a premium/enhanced voice
                        for (const name of preferredNames) {
                            bestVoice = voices.find(v => v.name.includes(name) && v.lang.startsWith('en'));
                            if (bestVoice) break;
                        }
                        
                        // Second try: any en-US voice
                        if (!bestVoice) {
                            bestVoice = voices.find(v => v.lang === 'en-US') || 
                                       voices.find(v => v.lang.startsWith('en')) || 
                                       voices[0];
                        }
                        
                        if (bestVoice) {
                            utterance.voice = bestVoice;
                            console.log('üó£Ô∏è Using voice:', bestVoice.name);
                        }
                        
                        utterance.onstart = () => {
                            this.isSpeaking = true;
                            console.log('‚ñ∂Ô∏è Started speaking at rate:', utterance.rate);
                        };
                        
                        utterance.onend = () => {
                            console.log('‚èπÔ∏è Finished speaking');
                            // Small delay before allowing input again
                            setTimeout(() => {
                                this.isSpeaking = false;
                                console.log('‚úÖ Ready for input');
                            }, 500); // 500ms buffer after speech ends
                            resolve();
                        };
                        
                        utterance.onerror = (event) => {
                            console.error('‚ùå Speech error:', event);
                            this.isSpeaking = false;
                            resolve(); // Resolve anyway to not block
                        };
                        
                        try {
                            this.synthesis.speak(utterance);
                        } catch (error) {
                            console.error('‚ùå Speak error:', error);
                            this.isSpeaking = false;
                            resolve();
                        }
                    }, 100); // 100ms delay helps iOS
                });
            }

            startContinuousListening(onResult) {
                if (!this.recognition) {
                    console.error('Speech recognition not available');
                    return false;
                }

                this.recognition.onresult = (event) => {
                    const last = event.results.length - 1;
                    const transcript = event.results[last][0].transcript.trim();
                    const confidence = event.results[last][0].confidence;
                    console.log('üé§ Heard:', transcript, '(confidence:', confidence, ')');
                    document.getElementById('yourMessage').textContent = `You: "${transcript}"`;
                    
                    // Don't process if caddie is speaking OR if transcript is empty
                    if (!this.isSpeaking && transcript.length > 0) {
                        console.log('‚úÖ Processing command:', transcript);
                        onResult(transcript);
                    } else if (this.isSpeaking) {
                        console.log('‚è∏Ô∏è Caddie is speaking, ignoring input');
                    } else {
                        console.log('‚ö†Ô∏è Empty transcript, ignoring');
                    }
                };

                this.recognition.onerror = (event) => {
                    console.error('üî¥ Recognition error:', event.error);
                    if (event.error === 'not-allowed') {
                        document.getElementById('caddieMessage').textContent = 
                            'Microphone permission needed. Check Settings > Safari > Microphone.';
                        document.getElementById('voiceStatus').textContent = 'üîá Mic permission denied';
                    } else if (event.error === 'no-speech') {
                        console.log('‚ö™ No speech detected, continuing...');
                        // Don't stop for no-speech in continuous mode
                        return;
                    } else if (event.error === 'aborted') {
                        console.log('‚ö™ Recognition aborted, restarting...');
                    } else {
                        console.log('‚ö†Ô∏è Other error:', event.error, '- attempting restart');
                    }
                };

                this.recognition.onend = () => {
                    console.log('üîµ Recognition ended');
                    // Auto-restart if in continuous mode
                    if (this.continuousMode) {
                        console.log('üîÑ Auto-restarting recognition...');
                        setTimeout(() => {
                            if (this.continuousMode) { // Double-check we're still in continuous mode
                                try {
                                    this.recognition.start();
                                    console.log('‚úÖ Recognition restarted');
                                } catch (e) {
                                    if (e.message.includes('already started')) {
                                        console.log('‚ö™ Already running, no restart needed');
                                    } else {
                                        console.error('‚ùå Restart failed:', e.message);
                                    }
                                }
                            }
                        }, 300); // Increased delay for iOS
                    }
                };

                this.recognition.onstart = () => {
                    console.log('üü¢ Recognition started');
                };

                try {
                    this.recognition.start();
                    this.continuousMode = true;
                    this.isListening = true;
                    console.log('üéôÔ∏è Continuous listening activated');
                    return true;
                } catch (error) {
                    console.error('‚ùå Could not start continuous listening:', error);
                    return false;
                }
            }

            stopContinuousListening() {
                this.continuousMode = false;
                this.isListening = false;
                if (this.recognition) {
                    this.recognition.stop();
                }
            }

            // Keep the old listen method for backwards compatibility
            listen() {
                return new Promise((resolve, reject) => {
                    if (!this.recognition) {
                        reject('Speech recognition not available');
                        return;
                    }

                    const tempRecognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                    tempRecognition.continuous = false;
                    tempRecognition.interimResults = false;
                    tempRecognition.lang = 'en-US';

                    tempRecognition.onresult = (event) => {
                        const transcript = event.results[0][0].transcript;
                        document.getElementById('yourMessage').textContent = `You: "${transcript}"`;
                        resolve(transcript);
                    };

                    tempRecognition.onerror = (event) => {
                        if (event.error === 'not-allowed') {
                            reject('Microphone access denied. Please allow microphone in your browser settings.');
                        } else if (event.error === 'no-speech') {
                            reject('No speech detected');
                        } else {
                            reject(event.error);
                        }
                    };

                    try {
                        tempRecognition.start();
                    } catch (error) {
                        reject('Could not start listening');
                    }
                });
            }
        }

        // GPS Simulator
        // Real GPS Tracking System
        class GPSTracker {
            constructor() {
                this.currentLocation = null;
                this.pinLocation = null;
                this.lastShotLocation = null;
                this.watchId = null;
                this.isTracking = false;
                this.manualDistance = null; // Verbal distance override
            }

            async requestPermission() {
                if (!('geolocation' in navigator)) {
                    console.error('‚ùå GPS not supported on this device');
                    return false;
                }

                try {
                    // Request location permission
                    const position = await new Promise((resolve, reject) => {
                        navigator.geolocation.getCurrentPosition(resolve, reject, {
                            enableHighAccuracy: true,
                            timeout: 10000,
                            maximumAge: 0
                        });
                    });

                    console.log('‚úÖ GPS permission granted');
                    this.currentLocation = {
                        lat: position.coords.latitude,
                        lon: position.coords.longitude,
                        altitude: position.coords.altitude,
                        accuracy: position.coords.accuracy
                    };
                    return true;
                } catch (error) {
                    console.error('‚ùå GPS permission denied:', error);
                    return false;
                }
            }

            startTracking(onUpdate) {
                if (this.isTracking) return;

                this.watchId = navigator.geolocation.watchPosition(
                    (position) => {
                        this.currentLocation = {
                            lat: position.coords.latitude,
                            lon: position.coords.longitude,
                            altitude: position.coords.altitude,
                            accuracy: position.coords.accuracy
                        };
                        
                        console.log('üìç GPS Update:', this.currentLocation);
                        
                        if (onUpdate) {
                            onUpdate(this.currentLocation);
                        }
                    },
                    (error) => {
                        console.error('‚ö†Ô∏è GPS error:', error.message);
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 5000,
                        maximumAge: 0
                    }
                );

                this.isTracking = true;
                console.log('üõ∞Ô∏è GPS tracking started');
            }

            stopTracking() {
                if (this.watchId !== null) {
                    navigator.geolocation.clearWatch(this.watchId);
                    this.watchId = null;
                    this.isTracking = false;
                    console.log('‚èπÔ∏è GPS tracking stopped');
                }
            }

            setPinLocation(lat, lon) {
                this.pinLocation = { lat, lon };
                console.log('üìç Pin set at:', this.pinLocation);
            }

            getDistance() {
                // Use verbal distance if set (player told us)
                if (this.manualDistance) {
                    return this.manualDistance;
                }
                
                if (!this.currentLocation || !this.pinLocation) {
                    return null; // No distance available
                }

                // Calculate distance to pin in yards
                const distance = this.calculateDistance(
                    this.currentLocation.lat,
                    this.currentLocation.lon,
                    this.pinLocation.lat,
                    this.pinLocation.lon
                );

                return Math.round(distance);
            }

            calculateDistance(lat1, lon1, lat2, lon2) {
                // Haversine formula for distance between two GPS points
                const R = 6371e3; // Earth radius in meters
                const œÜ1 = lat1 * Math.PI / 180;
                const œÜ2 = lat2 * Math.PI / 180;
                const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
                const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

                const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                          Math.cos(œÜ1) * Math.cos(œÜ2) *
                          Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                const meters = R * c;
                const yards = meters * 1.09361; // Convert to yards

                return yards;
            }

            recordShotStart() {
                // Record position before shot
                if (this.currentLocation) {
                    this.lastShotLocation = { ...this.currentLocation };
                    console.log('üì∏ Shot position recorded');
                }
            }

            getLastShotDistance() {
                // Calculate how far the ball traveled
                if (!this.lastShotLocation || !this.currentLocation) {
                    return null;
                }

                const distance = this.calculateDistance(
                    this.lastShotLocation.lat,
                    this.lastShotLocation.lon,
                    this.currentLocation.lat,
                    this.currentLocation.lon
                );

                return Math.round(distance);
            }

            // Compatibility methods for existing code
            moveCloser(yards) {
                // No longer needed with real GPS, but keep for compatibility
                console.log('‚ö†Ô∏è moveCloser called (ignored with real GPS)');
            }

            reset(distance = 385) {
                // Reset pin location (would need user to set new pin)
                this.pinLocation = null;
                this.lastShotLocation = null;
                console.log('üîÑ GPS reset');
            }
        }

        // Main Caddie App
        class CaddieApp {
            constructor() {
                this.storage = new CaddieStorage();
                this.voice = new VoiceCaddie();
                this.gps = new GPSTracker();
                this.vectorPutting = new VectorPuttingCalculator();
                this.ai = new ClaudeAI(); // ü§ñ AI BRAIN!
                this.keepAlive = new KeepAlive(); // üîí Prevent sleep & hold Bluetooth
                this.useAI = true; // Set to false to use old rule-based mode
                this.currentPuttData = {
                    distance: null,
                    slope: null,
                    stimp: 9, // Default medium-fast
                    breakDirection: null,
                    uphillDownhill: 'level'
                };
                this.setupMode = 'initial'; // initial, playing
                this.setupEventListeners();
                this.setupVisibilityHandling();
            }

            setupVisibilityHandling() {
                // Try to keep mic alive even when backgrounded
                // Only pause if fully hidden for extended time
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        console.log('App backgrounded - keeping mic alive if possible');
                        // DON'T stop listening immediately - iOS may just be dimming screen
                        // Set a delayed check instead
                        this.backgroundTimer = setTimeout(() => {
                            if (document.hidden && this.voice.continuousMode) {
                                console.log('Still backgrounded after 30s - pausing mic');
                                this.voice.stopContinuousListening();
                                this.wasListeningBeforeBackground = true;
                            }
                        }, 30000); // 30 second grace period
                    } else {
                        // App is back in foreground
                        clearTimeout(this.backgroundTimer);
                        console.log('App foregrounded - ensuring mic is active');
                        
                        // Resume silent audio for Bluetooth
                        this.keepAlive.ensureSilentAudio();
                        
                        if (this.wasListeningBeforeBackground && this.setupMode !== 'initial') {
                            // Auto-resume listening
                            setTimeout(() => {
                                const started = this.voice.startContinuousListening((text) => {
                                    this.processCommand(text);
                                });
                                if (started) {
                                    document.getElementById('voiceOrb').classList.add('listening');
                                    document.getElementById('voiceStatus').textContent = 'üé§ LIVE - Always listening';
                                }
                                this.wasListeningBeforeBackground = false;
                            }, 500);
                        }
                    }
                });

                // Also handle when app loses focus (iOS-specific)
                window.addEventListener('blur', () => {
                    console.log('App lost focus');
                    if (this.voice.continuousMode) {
                        this.voice.stopContinuousListening();
                    }
                });

                window.addEventListener('focus', () => {
                    console.log('App gained focus');
                    if (this.wasListeningBeforeBackground && this.setupMode !== 'initial') {
                        setTimeout(() => {
                            const started = this.voice.startContinuousListening((text) => {
                                this.processCommand(text);
                            });
                            if (started) {
                                document.getElementById('voiceOrb').classList.add('listening');
                                document.getElementById('voiceStatus').textContent = 'üé§ LIVE - Always listening';
                            }
                        }, 500);
                    }
                });
            }

            setupEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('voiceOrb').addEventListener('click', () => this.handleVoice());
                document.getElementById('statsBtn').addEventListener('click', () => this.speakStats());
                document.getElementById('historyBtn').addEventListener('click', () => this.speakHistory());
                
                // üéß SHOKZ BUTTON INTEGRATION
                // Your Shokz play/pause button controls the microphone!
                if ('mediaSession' in navigator) {
                    console.log('üéß Shokz button integration enabled');
                    
                    try {
                        // Pause button = Mute mic
                        navigator.mediaSession.setActionHandler('pause', () => {
                            console.log('üéß Shokz PAUSE - Muting mic');
                            this.muteMic();
                        });
                        
                        // Play button = Unmute mic  
                        navigator.mediaSession.setActionHandler('play', () => {
                            console.log('üéß Shokz PLAY - Unmuting mic');
                            this.unmuteMic();
                        });
                        
                        // Set dummy metadata so media session stays active
                        navigator.mediaSession.metadata = new MediaMetadata({
                            title: 'Golf Caddie - Listening',
                            artist: 'AI Assistant',
                            album: 'Round in Progress'
                        });
                    } catch (error) {
                        console.log('‚ö†Ô∏è MediaSession setup error (non-critical):', error.message);
                    }
                }
            }
            
            muteMic() {
                if (this.voice.continuousMode) {
                    this.voice.stopContinuousListening();
                    document.getElementById('voiceStatus').textContent = 'üîá Muted (Press Shokz to unmute)';
                    document.getElementById('voiceOrb').classList.remove('listening');
                    console.log('üîá Mic muted');
                }
            }
            
            unmuteMic() {
                if (!this.voice.continuousMode) {
                    const started = this.voice.startContinuousListening((text) => {
                        this.processCommand(text);
                    });
                    if (started) {
                        document.getElementById('voiceStatus').textContent = 'üé§ LIVE - Always listening';
                        document.getElementById('voiceOrb').classList.add('listening');
                        console.log('üé§ Mic unmuted');
                    }
                }
            }
            
            toggleMic() {
                if (this.voice.continuousMode) {
                    this.muteMic();
                } else {
                    this.unmuteMic();
                }
            }

            async start() {
                document.getElementById('welcomeScreen').classList.add('hidden');
                document.getElementById('mainApp').style.display = 'flex';
                
                // API key handled by server proxy ‚Äî no prompt needed
                console.log('‚úÖ AI features enabled via server proxy');
                
                // iOS REQUIRES user interaction before speech works
                try {
                    const dummyUtterance = new SpeechSynthesisUtterance(' ');
                    window.speechSynthesis.speak(dummyUtterance);
                    await new Promise(resolve => setTimeout(resolve, 100));
                } catch (error) {
                    console.log('Audio init:', error);
                }
                
                // Request GPS permission
                const gpsGranted = await this.gps.requestPermission();
                if (gpsGranted) {
                    this.gps.startTracking((location) => {
                        this.updateDisplay();
                    });
                }
                
                // Start keep-alive systems (wake lock, Bluetooth audio hold, no-sleep)
                await this.keepAlive.start();
                
                // AI-driven conversational setup
                this.setupMode = 'ai_setup';
                
                // Check if we have clubs configured already
                const hasCustomClubs = this.storage.data.profile.clubDistances['Driver'] !== 250 || 
                                        this.storage.data.profile.clubDistances['7 Iron'] !== 150;
                
                let setupPrompt = '';
                if (hasCustomClubs) {
                    setupPrompt = "Hey, welcome back! I've got your clubs dialed in. What course are we playing today?";
                } else {
                    setupPrompt = "Hey! I'm your caddie. Before we tee off, let's get to know your game. What course are we playing today, and do you want to set up your club distances?";
                }
                
                try {
                    await this.voice.speak(setupPrompt);
                } catch (error) {
                    console.error('Speech error on start:', error);
                    document.getElementById('caddieMessage').textContent = setupPrompt;
                }
                
                // Start continuous listening mode
                const started = this.voice.startContinuousListening((text) => {
                    this.processCommand(text);
                });
                
                if (started) {
                    document.getElementById('voiceOrb').classList.add('listening');
                    document.getElementById('voiceStatus').textContent = 'üé§ LIVE - Always listening';
                } else {
                    await this.voice.speak("Tap the microphone to enable voice control.");
                }
            }

            async handleVoice() {
                // Use the new toggle function (same one Shokz uses)
                this.toggleMic();
            }

            async autoListen() {
                // Not needed in continuous mode - already always listening
            }

            async processCommand(text) {
                const lower = text.toLowerCase();

                // ==========================================
                // VOICE SPEED - local only, instant response
                // ==========================================
                if (lower.includes('slow down') || lower.includes('slower') || lower.includes('talk slower')) {
                    const currentSpeed = this.storage.data.profile.voiceSpeed || 1.0;
                    const newSpeed = Math.max(0.5, currentSpeed - 0.2);
                    this.storage.data.profile.voiceSpeed = newSpeed;
                    this.storage.save();
                    await this.voice.speak(`Slowing down to ${Math.round(newSpeed * 100)}% speed.`);
                    return;
                }
                if (lower.includes('speed up') || lower.includes('faster') || lower.includes('talk faster')) {
                    const currentSpeed = this.storage.data.profile.voiceSpeed || 1.0;
                    const newSpeed = Math.min(2.0, currentSpeed + 0.2);
                    this.storage.data.profile.voiceSpeed = newSpeed;
                    this.storage.save();
                    await this.voice.speak(`Speeding up to ${Math.round(newSpeed * 100)}% speed.`);
                    return;
                }
                if (lower.includes('normal speed') || lower.includes('regular speed')) {
                    this.storage.data.profile.voiceSpeed = 1.0;
                    this.storage.save();
                    await this.voice.speak(`Back to normal speed.`);
                    return;
                }

                // ==========================================
                // CLUB SETUP MODE - structured input needed
                // ==========================================
                if (this.setupMode === 'club_setup') {
                    const distMatch = text.match(/(\d+)/);
                    if (distMatch) {
                        const distance = parseInt(distMatch[1]);
                        const currentClub = this.clubsToSetup[this.clubSetupIndex];
                        
                        this.storage.data.profile.clubDistances[currentClub] = distance;
                        this.storage.save();
                        
                        this.clubSetupIndex++;
                        
                        if (this.clubSetupIndex < this.clubsToSetup.length) {
                            await this.voice.speak(`${currentClub}, ${distance} yards. How far does your ${this.clubsToSetup[this.clubSetupIndex]} go?`);
                        } else {
                            await this.voice.speak(`Perfect! All clubs configured. Ready to play!`);
                            this.setupMode = 'ai_setup';
                        }
                        return;
                    } else if (lower.includes('skip') || lower.includes('done') || lower.includes('nevermind') || lower.includes('finish')) {
                        await this.voice.speak("Club setup complete!");
                        this.setupMode = 'ai_setup';
                        return;
                    }
                }

                // ==========================================
                // DETECT & STORE: Club distances said naturally
                // "my driver goes 280" / "7 iron is 155"
                // ==========================================
                const clubDistancePattern = /(?:my\s+)?(\w+(?:\s+\w+)?)\s+(?:goes|is|about|around)\s+(\d+)/i;
                const clubDistMatch = text.match(clubDistancePattern);
                if (clubDistMatch) {
                    const detectedClub = this.detectClub(clubDistMatch[1]);
                    const distance = parseInt(clubDistMatch[2]);
                    if (detectedClub && distance >= 40 && distance <= 400) {
                        this.storage.data.profile.clubDistances[detectedClub] = distance;
                        this.storage.save();
                        console.log(`‚úÖ Stored: ${detectedClub} = ${distance} yards`);
                        // Don't return ‚Äî let AI respond conversationally too
                    }
                }
                
                // ==========================================
                // DETECT & STORE: Course and hole setup
                // ==========================================
                if (!this.storage.data.currentRound) {
                    // Try to detect course name
                    const coursePatterns = [
                        /(?:playing|at|going to|we're at)\s+(.+?)(?:\s+(?:today|starting|hole)|$)/i,
                        /(?:course is|course called)\s+(.+?)(?:\s|$)/i
                    ];
                    for (const pattern of coursePatterns) {
                        const match = text.match(pattern);
                        if (match) {
                            this.tempCourseName = match[1].trim();
                            break;
                        }
                    }
                    
                    // Try to detect hole number
                    const holeMatch = lower.match(/(?:hole|starting|start)\s+(\d+)/i) || lower.match(/^(\d+)$/);
                    if (holeMatch && this.tempCourseName) {
                        const holeNum = parseInt(holeMatch[1]);
                        if (holeNum >= 1 && holeNum <= 18) {
                            this.storage.startRound(this.tempCourseName, holeNum);
                            this.updateDisplay();
                            this.setupMode = 'playing';
                            console.log(`‚úÖ Round started: ${this.tempCourseName}, hole ${holeNum}`);
                        }
                    }
                }

                // ==========================================
                // DETECT & TRACK: Game actions (shots, holes)
                // These update game state THEN AI responds
                // ==========================================
                const hole = this.storage.getCurrentHole();
                
                // Verbal distance updates: "I have 150", "150 yards", "150 out"
                const yardMatch = text.match(/(\d+)\s*(?:yards?|out|left|remaining)?/i);
                if (yardMatch && !this.detectClub(text)) {
                    const dist = parseInt(yardMatch[1]);
                    if (dist >= 10 && dist <= 600) {
                        // Override GPS distance with verbal distance
                        this.gps.manualDistance = dist;
                        this.updateDisplay();
                        console.log(`‚úÖ Distance updated verbally: ${dist} yards`);
                    }
                }
                
                if (hole && this.setupMode === 'playing') {
                    // Club setup trigger
                    if (lower.includes('set up') && lower.includes('club')) {
                        this.setupMode = 'club_setup';
                        this.clubSetupIndex = 0;
                        this.clubsToSetup = ['Driver', '3 Wood', '5 Wood', 'Hybrid', '4 Iron', '5 Iron', '6 Iron', '7 Iron', '8 Iron', '9 Iron', 'Pitching Wedge', 'Gap Wedge', 'Sand Wedge', 'Lob Wedge'];
                        await this.voice.speak(`Okay, let's set up your clubs. How far does your ${this.clubsToSetup[0]} go?`);
                        return;
                    }
                    
                    // Made putt / holed out
                    if (lower.includes('made it') || lower.includes('holed') || lower.includes('sunk') || lower.includes('drained') ||
                        (lower.includes('made') && lower.includes('putt'))) {
                        const totalShots = hole.shots.length + (hole.state === 'green' ? 1 : 0);
                        const par = hole.par || 4;
                        const diff = totalShots - par;
                        
                        this.storage.completeHole(totalShots);
                        this.storage.nextHole();
                        this.gps.manualDistance = null; // Reset for new hole
                        this.updateDisplay();
                        
                        const nextHole = this.storage.getCurrentHole();
                        // Let AI celebrate and introduce next hole
                    }
                    
                    // Score for hole directly: "scored 5" / "5 on the hole"
                    if (lower.includes('scored') || lower.includes('on the hole') || lower.includes('for the hole')) {
                        const scoreMatch = text.match(/(\d+)/);
                        if (scoreMatch) {
                            const score = parseInt(scoreMatch[1]);
                            if (score >= 1 && score <= 15) {
                                this.storage.completeHole(score);
                                this.storage.nextHole();
                                this.gps.manualDistance = null; // Reset for new hole
                                this.updateDisplay();
                            }
                        }
                    }
                    
                    // Detect club being hit ‚Äî record the shot
                    const club = this.detectClub(text);
                    if (club && !lower.includes('what') && !lower.includes('how far') && !lower.includes('my')) {
                        this.gps.recordShotStart();
                        const distance = this.gps.getDistance();
                        this.storage.recordShot(club, distance, { 
                            state: hole.state,
                            windy: hole.conditions?.windy
                        });
                        
                        if (club === 'Putter') {
                            hole.putts = (hole.putts || 0) + 1;
                            hole.state = 'green';
                        } else if (hole.state === 'tee') {
                            hole.state = 'fairway';
                        }
                        
                        console.log(`‚úÖ Shot recorded: ${club}`);
                    }
                    
                    // Update lie state
                    if (lower.includes('on the green') || lower.includes('hit the green')) {
                        hole.state = 'green';
                    } else if (lower.includes('fairway')) {
                        hole.state = 'fairway';
                    }
                    
                    // Wind detection
                    if (lower.includes('wind') || lower.includes('windy')) {
                        hole.conditions = hole.conditions || {};
                        hole.conditions.windy = true;
                    }
                    
                    // End round detection
                    if (lower.includes('end round') || lower.includes('finish round') || lower.includes('done for today') || lower.includes('that\'s it')) {
                        // Save round and generate summary
                        const round = this.storage.data.currentRound;
                        if (round && round.holes.length > 0) {
                            // Save round to history
                            this.storage.data.rounds.push({...round});
                            this.storage.data.stats.totalRounds++;
                            this.storage.save();
                            
                            // Generate AI round summary in background
                            this.ai.generateRoundSummary(round);
                            
                            // Also save conversation memory
                            this.ai.generateMemoryUpdate(this.ai.conversationHistory.slice(-10));
                        }
                    }
                }

                // ==========================================
                // EVERYTHING GOES TO AI
                // Claude is the brain ‚Äî always responds
                // ==========================================
                console.log('ü§ñ Sending to Claude AI:', text);
                
                const context = {
                    currentHole: this.storage.getCurrentHole(),
                    distance: this.gps.getDistance(),
                    score: this.storage.data.currentRound?.score,
                    course: this.storage.data.currentRound?.course,
                    holesPlayed: this.storage.data.currentRound?.holes?.length || 0,
                    conditions: this.storage.getCurrentHole()?.conditions,
                    clubHistory: this.storage.data.clubPerformance,
                    playerClubs: this.storage.data.profile.clubDistances
                };
                
                try {
                    const aiResponse = await this.ai.ask(text, context);
                    await this.voice.speak(aiResponse);
                } catch (err) {
                    console.error('AI error:', err);
                    await this.voice.speak("Having trouble connecting. Check your signal and try again.");
                }
            }

            // handleGameCommand removed ‚Äî AI handles all game conversation now

            getAdvancedPuttingAdvice(feet, context = {}) {
                // VECTOR PUTTING METHODOLOGY
                let advice = '';
                
                // First, explain what we're doing (Vector Putting style)
                if (feet <= 3) {
                    advice = `${feet} feet. Using Vector Putting: aim point is inside the cup. Optimal speed - die it 12 inches past if you miss.`;
                } else if (feet <= 5) {
                    advice = `${feet} footer. Vector Putting says aim for optimal terminal velocity - imagine the ball dying 12 inches past the hole.`;
                } else if (feet <= 10) {
                    advice = `${feet} feet. This is a precision putt. Find your Zero Break Line - that's the line straight downhill. Your gravity vector will determine your aim point.`;
                } else if (feet <= 20) {
                    advice = `${feet} feet. Long putt - focus on getting within the 3-foot circle. Speed control is critical here.`;
                } else if (feet <= 40) {
                    advice = `${feet} footer. This is lag putting territory. Visualize a 3-foot circle around the hole. Speed matters more than line.`;
                } else {
                    advice = `Really long, ${feet} feet. Approach putt - just get it inside that 3-foot circle. Don't leave yourself a difficult second putt.`;
                }
                
                // Add slope-specific Vector Putting guidance
                if (context.slope === 'uphill') {
                    advice += " Uphill - the gravity vector works against you. Hit it firmer to maintain optimal terminal velocity.";
                } else if (context.slope === 'downhill') {
                    advice += " Downhill - gravity assists. Less speed needed. Let it die into the hole.";
                }
                
                // Add break context using Zero Break Line concept
                if (context.break === 'left-to-right') {
                    advice += " Breaking left to right - your Zero Break Line is diagonal. Aim point is left of center, let the ball curve down to the hole.";
                } else if (context.break === 'right-to-left') {
                    advice += " Right to left - Zero Break Line runs diagonal the other way. Aim right, trust the gravity vector.";
                }
                
                // Green speed affects everything (Vector Putting principle)
                if (context.speed === 'fast') {
                    advice += " Fast greens - smaller gravity vector. Less break than you think.";
                } else if (context.speed === 'slow') {
                    advice += " Slow greens - larger gravity vector. More break than you expect.";
                }
                
                // Distance-specific Vector Putting wisdom
                if (feet <= 5) {
                    advice += " Remember: optimal terminal velocity is key. Not too fast, not dying at the hole.";
                } else if (feet > 10 && feet <= 25) {
                    advice += " The ball will break more in the final 3 feet as it slows down. Trust your read.";
                }
                
                return advice;
            }

            getLagPuttAdvice(distance) {
                // Vector Putting lag putt philosophy
                if (distance <= 10) {
                    return "Good lag. Vector Putting principle: always aim for 12 inches past. Never up, never in.";
                } else if (distance <= 25) {
                    return "Solid lag putt. In Vector Putting, we think about that 3-foot circle. You're in lag range now.";
                } else {
                    return "Great distance control on that long putt. Vector Putting teaches speed over line on putts this long.";
                }
            }

            detectClub(text) {
                const patterns = [
                    { regex: /\bdriver\b/i, name: 'Driver' },
                    { regex: /\b3\s*wood\b/i, name: '3 Wood' },
                    { regex: /\b5\s*wood\b/i, name: '5 Wood' },
                    { regex: /\bhybrid\b/i, name: 'Hybrid' },
                    { regex: /\b(\d)\s*iron\b/i, match: (m) => `${m[1]} Iron` },
                    { regex: /\bpitching\s*wedge\b|\bpw\b/i, name: 'Pitching Wedge' },
                    { regex: /\bsand\s*wedge\b|\bsw\b/i, name: 'Sand Wedge' },
                    { regex: /\blob\s*wedge\b|\blw\b/i, name: 'Lob Wedge' },
                    { regex: /\bgap\s*wedge\b|\bgw\b/i, name: 'Gap Wedge' },
                    { regex: /\bputter\b/i, name: 'Putter' },
                ];

                for (let p of patterns) {
                    const match = text.match(p.regex);
                    if (match) {
                        return p.match ? p.match(match) : p.name;
                    }
                }
                return null;
            }

            updateDisplay() {
                const round = this.storage.data.currentRound;
                if (round) {
                    document.getElementById('currentHole').textContent = round.currentHole.number;
                    document.getElementById('scoreDisplay').textContent = round.score;
                    document.getElementById('courseInfo').textContent = round.course;
                }
                
                const dist = this.gps.getDistance();
                document.getElementById('distanceDisplay').textContent = dist < 100 ? `${dist}y` : Math.round(dist/10)*10;
            }

            async speakStats() {
                const round = this.storage.data.currentRound;
                if (!round || round.holes.length === 0) {
                    await this.voice.speak("No holes completed yet. Let's get some data first!");
                    return;
                }
                
                const holesPlayed = round.holes.length;
                const totalScore = round.score;
                const par = round.holes.reduce((sum, h) => sum + (h.par || 4), 0);
                const diff = totalScore - par;
                const diffStr = diff === 0 ? 'even par' : diff > 0 ? `${diff} over` : `${Math.abs(diff)} under`;
                
                // Calculate GIR
                let greensHit = 0;
                let totalPutts = 0;
                let upAndDownAttempts = 0;
                let upAndDownMade = 0;
                
                round.holes.forEach(hole => {
                    const holePar = hole.par || 4;
                    const shotsToGreen = hole.shots ? hole.shots.filter(s => s.club !== 'Putter').length : 0;
                    const putts = hole.shots ? hole.shots.filter(s => s.club === 'Putter').length : 0;
                    
                    totalPutts += putts;
                    
                    // GIR = reached green in par minus 2 strokes
                    if (shotsToGreen <= holePar - 2) {
                        greensHit++;
                    } else if (hole.finalScore && hole.finalScore <= holePar) {
                        // Missed green but still made par or better = up and down
                        upAndDownAttempts++;
                        upAndDownMade++;
                    } else if (shotsToGreen > holePar - 2) {
                        upAndDownAttempts++;
                    }
                });
                
                const girPercent = Math.round((greensHit / holesPlayed) * 100);
                const puttsPerHole = (totalPutts / holesPlayed).toFixed(1);
                const upDownPercent = upAndDownAttempts > 0 ? Math.round((upAndDownMade / upAndDownAttempts) * 100) : 0;
                
                let statsMsg = `Through ${holesPlayed} holes, you're ${diffStr}, ${totalScore} total. `;
                statsMsg += `Greens in regulation: ${girPercent}%, ${greensHit} of ${holesPlayed}. `;
                statsMsg += `Averaging ${puttsPerHole} putts per hole, ${totalPutts} total. `;
                if (upAndDownAttempts > 0) {
                    statsMsg += `Up and downs: ${upAndDownMade} of ${upAndDownAttempts}, ${upDownPercent}%. `;
                }
                
                // Add encouragement via AI
                if (this.ai.hasValidKey()) {
                    const context = {
                        score: totalScore,
                        holesPlayed,
                        course: round.course,
                        girPercent,
                        puttsPerHole,
                        upDownPercent
                    };
                    const aiComment = await this.ai.ask(
                        `Quick one-liner coaching comment on my stats so far: ${diffStr}, ${girPercent}% GIR, ${puttsPerHole} putts/hole, ${upDownPercent}% up-and-down. Keep it to one sentence.`,
                        context
                    );
                    statsMsg += aiComment;
                }
                
                await this.voice.speak(statsMsg);
            }

            async speakHistory() {
                const rounds = this.storage.data.rounds;
                const currentRound = this.storage.data.currentRound;
                
                if ((!rounds || rounds.length === 0) && !currentRound) {
                    await this.voice.speak("No round history yet. Let's build some data!");
                    return;
                }
                
                let historyMsg = '';
                
                // Recent rounds summary
                const recentRounds = (rounds || []).slice(-5).reverse();
                if (recentRounds.length > 0) {
                    historyMsg += `You've played ${rounds.length} total round${rounds.length > 1 ? 's' : ''}. `;
                    
                    // Calculate averages across rounds
                    let totalScores = 0;
                    let totalHoles = 0;
                    let totalPutts = 0;
                    
                    recentRounds.forEach(round => {
                        const holes = round.holes || [];
                        totalScores += round.score || 0;
                        totalHoles += holes.length;
                        holes.forEach(h => {
                            totalPutts += h.shots ? h.shots.filter(s => s.club === 'Putter').length : 0;
                        });
                    });
                    
                    if (totalHoles > 0) {
                        const avgScore = (totalScores / recentRounds.length).toFixed(0);
                        const avgPutts = (totalPutts / totalHoles).toFixed(1);
                        historyMsg += `Last ${recentRounds.length} rounds: averaging ${avgScore} per round, ${avgPutts} putts per hole. `;
                    }
                    
                    // Last round detail
                    const last = recentRounds[0];
                    const lastDate = new Date(last.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    historyMsg += `Most recent: ${last.course}, ${lastDate}, scored ${last.score} over ${last.holes?.length || '?'} holes. `;
                } else {
                    historyMsg += "No completed rounds yet. ";
                }
                
                // Current round progress
                if (currentRound && currentRound.holes.length > 0) {
                    historyMsg += `Today at ${currentRound.course}: ${currentRound.score} through ${currentRound.holes.length} holes.`;
                }
                
                await this.voice.speak(historyMsg);
            }

            async speakInsights() {
                await this.voice.speak("What would you like to know? Ask me anything about golf, strategy, or Vector Putting.");
            }

            async openSettings() {
                const currentSpeed = this.storage.data.profile.voiceSpeed || 1.0;
                // Show debug info
                const debugInfo = `
Debug Info:
- Voice speed: ${Math.round(currentSpeed * 100)}%
- Speech synthesis: ${!!window.speechSynthesis ? 'Yes' : 'No'}
- Speech recognition: ${!!this.voice.recognition ? 'Yes' : 'No'}
- Continuous mode: ${this.voice.continuousMode ? 'Yes' : 'No'}
- Is listening: ${this.voice.isListening ? 'Yes' : 'No'}
- Is speaking: ${this.voice.isSpeaking ? 'Yes' : 'No'}
- Setup mode: ${this.setupMode}
- Current round: ${this.storage.data.currentRound ? 'Active' : 'None'}

Voice Commands:
- "Slow down" / "Faster"
- "Voice speed 80" (50-200%)
- "Normal speed"

Check console (F12) for logs.
                `.trim();
                
                alert(debugInfo);
                console.log('Full state:', {
                    storage: this.storage.data,
                    voice: this.voice,
                    setupMode: this.setupMode
                });
            }
        }

        // Initialize
        let app;
        document.addEventListener('DOMContentLoaded', () => {
            app = new CaddieApp();
        });
    </script>
</body>
</html>
