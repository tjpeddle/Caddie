<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Voice Golf Caddie</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=JetBrains+Mono:wght@400;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'DM Sans', sans-serif;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .main-container {
            width: 100%;
            max-width: 500px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }
        
        /* Header */
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-top: 20px;
        }
        
        .header h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .header .subtitle {
            font-size: 0.9rem;
            opacity: 0.7;
            font-family: 'JetBrains Mono', monospace;
        }
        
        /* Voice Interface - Main Focus */
        .voice-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 30px;
        }
        
        .voice-orb {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #4ade80, #22c55e);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 20px 60px rgba(74, 222, 128, 0.4);
            position: relative;
        }
        
        .voice-orb::before {
            content: '';
            position: absolute;
            width: 220px;
            height: 220px;
            border-radius: 50%;
            border: 2px solid rgba(74, 222, 128, 0.3);
            animation: pulse-ring 2s infinite;
        }
        
        @keyframes pulse-ring {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.5;
            }
        }
        
        .voice-orb.listening {
            animation: listening-pulse 1s infinite;
            background: radial-gradient(circle at 30% 30%, #ef4444, #dc2626);
            box-shadow: 0 20px 60px rgba(239, 68, 68, 0.6);
        }
        
        @keyframes listening-pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }
        
        .voice-orb:active {
            transform: scale(0.95);
        }
        
        .voice-icon {
            font-size: 4rem;
        }
        
        .conversation {
            width: 100%;
            text-align: center;
            min-height: 80px;
            max-height: 200px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow: hidden;
        }
        
        .caddie-speaks {
            font-size: 1.1rem;
            line-height: 1.6;
            font-weight: 500;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-height: 150px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .you-said {
            font-size: 0.9rem;
            opacity: 0.6;
            font-family: 'JetBrains Mono', monospace;
            flex-shrink: 0;
        }
        
        /* Quick Info (hidden - data tracked internally) */
        
        /* Bottom Actions */
        .bottom-actions {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            padding-bottom: 20px;
        }
        
        .action-btn {
            padding: 14px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: white;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .action-btn:active {
            transform: scale(0.95);
            background: rgba(74, 222, 128, 0.3);
        }
        
        /* Welcome Screen */
        .welcome-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 40px;
        }
        
        .welcome-content {
            text-align: center;
            max-width: 400px;
        }
        
        .welcome-content h1 {
            font-size: 3rem;
            margin-bottom: 16px;
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .welcome-content p {
            font-size: 1.1rem;
            line-height: 1.8;
            opacity: 0.8;
            margin-bottom: 40px;
        }
        
        .start-btn {
            padding: 20px 40px;
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            border: none;
            border-radius: 50px;
            font-size: 1.2rem;
            font-weight: 700;
            color: #0f2027;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 10px 30px rgba(74, 222, 128, 0.4);
        }
        
        .start-btn:active {
            transform: scale(0.95);
        }
        
        .hidden {
            display: none;
        }
        
        /* Setup Mode */
        .setup-mode {
            display: none;
            text-align: center;
        }
        
        .setup-mode.active {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .setup-prompt {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <!-- Welcome Screen -->
    <div class="welcome-screen" id="welcomeScreen">
        <div class="welcome-content">
            <h1>‚õ≥ Voice Caddie</h1>
            <p>
                Put your phone in your bag.<br>
                Talk to me like a real caddie.<br>
                I'll help you play your best.
            </p>
            <button class="start-btn" id="startBtn">Let's Go</button>
        </div>
    </div>

    <!-- Main App -->
    <div class="main-container" id="mainApp" style="display: none;">
        
        <!-- Header -->
        <div class="header">
            <h1>‚õ≥ CADDIE</h1>
            <div class="subtitle" id="courseInfo">Ready when you are</div>
        </div>
        
        <!-- Hidden data holders (AI tracks these, no visual display needed) -->
        <div style="display:none;">
            <span id="currentHole">--</span>
            <span id="distanceDisplay">--</span>
            <span id="scoreDisplay">0</span>
        </div>
        
        <!-- Voice Interface -->
        <div class="voice-section">
            <button class="voice-orb" id="voiceOrb">
                <span class="voice-icon">üé§</span>
            </button>
            
            <div class="conversation">
                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 8px; color: #4ade80;" id="voiceStatus">
                    Tap mic to start
                </div>
                <div class="caddie-speaks" id="caddieMessage">
                    Ready to talk golf
                </div>
                <div class="you-said" id="yourMessage"></div>
                
                <!-- Simplified help -->
                <div style="font-size: 0.7rem; opacity: 0.5; margin-top: 10px; text-align: center;">
                    Tap mic or Shokz to mute/unmute
                </div>
            </div>
        </div>
        
        <!-- Bottom Actions -->
        <div class="bottom-actions" style="grid-template-columns: repeat(3, 1fr);">
            <button class="action-btn" id="statsBtn">üìà My Game</button>
            <button class="action-btn" id="greenReadBtn">üì∏ Green Read</button>
            <button class="action-btn" id="historyBtn">üèåÔ∏è History</button>
        </div>
        
        <!-- Hidden camera input -->
        <input type="file" id="cameraInput" accept="image/*" capture="environment" style="display:none;">
        
    </div>

    <script>
        // ==========================================
        // KEEP APP ALIVE & BLUETOOTH AUDIO LOCK
        // ==========================================
        
        class KeepAlive {
            constructor() {
                this.wakeLock = null;
                this.silentAudio = null;
                this.noSleepVideo = null;
            }
            
            async start() {
                // 1. Wake Lock API ‚Äî prevents screen from sleeping
                await this.requestWakeLock();
                
                // Re-acquire wake lock when page becomes visible again
                document.addEventListener('visibilitychange', async () => {
                    if (document.visibilityState === 'visible') {
                        await this.requestWakeLock();
                        this.ensureSilentAudio();
                    }
                });
                
                // 2. Silent audio loop ‚Äî keeps Bluetooth audio route active
                this.startSilentAudio();
                
                // 3. NoSleep video trick ‚Äî iOS fallback to prevent sleep
                this.startNoSleepVideo();
                
                console.log('üîí Keep-alive systems active');
            }
            
            async requestWakeLock() {
                try {
                    if ('wakeLock' in navigator) {
                        this.wakeLock = await navigator.wakeLock.request('screen');
                        this.wakeLock.addEventListener('release', () => {
                            console.log('‚ö†Ô∏è Wake lock released');
                        });
                        console.log('‚úÖ Wake lock acquired');
                    }
                } catch (err) {
                    console.log('Wake lock not available:', err.message);
                }
            }
            
            startSilentAudio() {
                try {
                    // Create AudioContext to hold Bluetooth route
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    const ctx = new AudioContext();
                    
                    // Create a silent oscillator
                    const oscillator = ctx.createOscillator();
                    const gain = ctx.createGain();
                    gain.gain.value = 0.001; // Nearly silent
                    oscillator.connect(gain);
                    gain.connect(ctx.destination);
                    oscillator.start();
                    
                    this.silentAudio = { ctx, oscillator, gain };
                    console.log('‚úÖ Silent audio loop active (Bluetooth lock)');
                } catch (err) {
                    console.log('Silent audio fallback:', err.message);
                }
            }
            
            ensureSilentAudio() {
                if (this.silentAudio?.ctx?.state === 'suspended') {
                    this.silentAudio.ctx.resume();
                    console.log('üîÑ Resumed silent audio');
                }
            }
            
            startNoSleepVideo() {
                try {
                    // Tiny looping video keeps iOS awake
                    const video = document.createElement('video');
                    video.setAttribute('playsinline', '');
                    video.setAttribute('muted', '');
                    video.setAttribute('loop', '');
                    video.style.position = 'fixed';
                    video.style.top = '-1px';
                    video.style.left = '-1px';
                    video.style.width = '1px';
                    video.style.height = '1px';
                    video.style.opacity = '0.01';
                    
                    // Minimal base64 mp4 (tiny silent video)
                    video.src = 'data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAA' +
                        'NBtZGF0AAACrgYF//+q3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0OCByMjYwMSBhMGNkN2' +
                        'QzIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNSAtIGh0dHA6Ly9' +
                        '3d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTMgZGVibG9j';
                    
                    document.body.appendChild(video);
                    
                    // Play on user interaction
                    const playVideo = () => {
                        video.play().catch(() => {});
                    };
                    document.addEventListener('click', playVideo, { once: true });
                    document.addEventListener('touchstart', playVideo, { once: true });
                    
                    this.noSleepVideo = video;
                    console.log('‚úÖ NoSleep video ready');
                } catch (err) {
                    console.log('NoSleep video fallback:', err.message);
                }
            }
            
            stop() {
                if (this.wakeLock) this.wakeLock.release();
                if (this.silentAudio) {
                    this.silentAudio.oscillator.stop();
                    this.silentAudio.ctx.close();
                }
                if (this.noSleepVideo) this.noSleepVideo.remove();
            }
        }
        
        // ==========================================
        // CLAUDE AI INTEGRATION
        // ==========================================
        
        class ClaudeAI {
            constructor() {
                // API key is handled server-side by Vercel proxy ‚Äî no key needed here!
                this.endpoint = 'https://caddie-proxy.vercel.app/api/chat';
                this.conversationHistory = [];
                this.memory = this.loadMemory();
                this.messageCount = 0;
            }

            hasValidKey() {
                return true; // Always valid ‚Äî proxy handles the key
            }

            setApiKey(key) {
                // No-op ‚Äî proxy handles the key
                console.log('‚úÖ API key handled by server proxy');
            }

            clearApiKey() {
                // No-op ‚Äî proxy handles the key
            }
            
            // ==========================================
            // PERSISTENT MEMORY SYSTEM
            // Survives app closes, swipe-outs, restarts
            // ==========================================
            
            loadMemory() {
                try {
                    const stored = localStorage.getItem('caddie_ai_memory');
                    return stored ? JSON.parse(stored) : this.getDefaultMemory();
                } catch (e) {
                    return this.getDefaultMemory();
                }
            }
            
            getDefaultMemory() {
                return {
                    playerNotes: [],      // AI observations about the player
                    swingTips: [],         // Tips discussed
                    tendencies: [],        // Patterns noticed (e.g. "slices driver")
                    roundSummaries: [],    // End-of-round AI summaries
                    preferences: [],       // Player preferences (e.g. "aggressive putter")
                    lastUpdated: null
                };
            }
            
            saveMemory() {
                try {
                    this.memory.lastUpdated = new Date().toISOString();
                    localStorage.setItem('caddie_ai_memory', JSON.stringify(this.memory));
                    console.log('üíæ AI memory saved');
                } catch (e) {
                    console.error('Memory save error:', e);
                }
            }
            
            addMemoryNote(category, note) {
                if (!this.memory[category]) return;
                // Keep last 20 notes per category
                this.memory[category].push({
                    note,
                    date: new Date().toISOString()
                });
                if (this.memory[category].length > 20) {
                    this.memory[category] = this.memory[category].slice(-20);
                }
                this.saveMemory();
            }
            
            getMemoryContext() {
                let memoryStr = '';
                
                if (this.memory.playerNotes.length > 0) {
                    const recentNotes = this.memory.playerNotes.slice(-5).map(n => n.note).join('; ');
                    memoryStr += `\n\nPlayer Notes from previous sessions: ${recentNotes}`;
                }
                
                if (this.memory.tendencies.length > 0) {
                    const tendencies = this.memory.tendencies.slice(-5).map(n => n.note).join('; ');
                    memoryStr += `\nPlayer tendencies: ${tendencies}`;
                }
                
                if (this.memory.swingTips.length > 0) {
                    const tips = this.memory.swingTips.slice(-3).map(n => n.note).join('; ');
                    memoryStr += `\nRecent tips discussed: ${tips}`;
                }
                
                if (this.memory.roundSummaries.length > 0) {
                    const lastRound = this.memory.roundSummaries.slice(-1)[0];
                    memoryStr += `\nLast round summary: ${lastRound.note}`;
                }
                
                if (this.memory.preferences.length > 0) {
                    const prefs = this.memory.preferences.slice(-5).map(n => n.note).join('; ');
                    memoryStr += `\nPlayer preferences: ${prefs}`;
                }
                
                return memoryStr;
            }
            
            async generateMemoryUpdate(conversationSlice) {
                // Every 10 messages, ask AI to extract key notes
                try {
                    const response = await fetch(this.endpoint, {
                        method: 'POST',
                        headers: { 'content-type': 'application/json' },
                        body: JSON.stringify({
                            model: 'claude-haiku-4-5-20251001',
                            max_tokens: 300,
                            system: `Extract key golf notes about this player from the conversation. Return ONLY a JSON object with these arrays (each item is a short string):
{"playerNotes": ["note1"], "tendencies": ["tendency1"], "swingTips": ["tip1"], "preferences": ["pref1"]}
Only include categories that have new info. Keep notes brief (under 15 words each).`,
                            messages: [{
                                role: 'user',
                                content: `Conversation to analyze:\n${conversationSlice.map(m => `${m.role}: ${m.content}`).join('\n')}`
                            }]
                        })
                    });
                    
                    const data = await response.json();
                    const text = data.content?.[0]?.text || '';
                    
                    // Parse AI response
                    const jsonMatch = text.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        const notes = JSON.parse(jsonMatch[0]);
                        for (const [category, items] of Object.entries(notes)) {
                            if (Array.isArray(items) && this.memory[category]) {
                                items.forEach(note => this.addMemoryNote(category, note));
                            }
                        }
                        console.log('üß† Memory updated from conversation');
                    }
                } catch (e) {
                    console.log('Memory update skipped:', e.message);
                }
            }
            
            async generateRoundSummary(roundData) {
                try {
                    const response = await fetch(this.endpoint, {
                        method: 'POST',
                        headers: { 'content-type': 'application/json' },
                        body: JSON.stringify({
                            model: 'claude-haiku-4-5-20251001',
                            max_tokens: 200,
                            system: 'Summarize this golf round in 2-3 sentences. Focus on what went well, what to improve, and key stats. Be specific.',
                            messages: [{
                                role: 'user',
                                content: `Round data: ${JSON.stringify(roundData)}\nConversation highlights: ${this.conversationHistory.slice(-6).map(m => `${m.role}: ${m.content}`).join('\n')}`
                            }]
                        })
                    });
                    
                    const data = await response.json();
                    const summary = data.content?.[0]?.text || '';
                    if (summary) {
                        this.addMemoryNote('roundSummaries', summary);
                        console.log('üìù Round summary saved');
                    }
                } catch (e) {
                    console.log('Round summary skipped:', e.message);
                }
            }

            async ask(userMessage, context = {}) {
                console.log('ü§ñ Asking Claude AI:', userMessage);
                
                // Build system context from game state + memory
                const systemContext = this.buildContext(context) + this.getMemoryContext();
                
                // Add user message to conversation
                this.conversationHistory.push({
                    role: 'user',
                    content: userMessage
                });
                
                this.messageCount++;
                
                try {
                    const controller = new AbortController();
                    const timeout = setTimeout(() => controller.abort(), 15000); // 15 second timeout
                    
                    const response = await fetch(this.endpoint, {
                        method: 'POST',
                        headers: {
                            'content-type': 'application/json'
                        },
                        signal: controller.signal,
                        body: JSON.stringify({
                            model: 'claude-haiku-4-5-20251001',
                            max_tokens: 300,
                            system: systemContext,
                            messages: this.conversationHistory.slice(-14)
                        })
                    });
                    
                    clearTimeout(timeout);

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('API Error Response:', errorText);
                        throw new Error(`API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('‚úÖ Claude AI responded');
                    
                    // Extract text response
                    let fullResponse = '';
                    for (const block of data.content) {
                        if (block.type === 'text') {
                            fullResponse += block.text;
                        }
                    }
                    
                    // Parse [DATA] block if present
                    let gameData = null;
                    let spokenResponse = fullResponse;
                    
                    const dataMatch = fullResponse.match(/\[DATA\]\s*(\{[\s\S]*?\})\s*$/);
                    if (dataMatch) {
                        try {
                            gameData = JSON.parse(dataMatch[1]);
                            // Strip [DATA] from spoken text
                            spokenResponse = fullResponse.replace(/\[DATA\][\s\S]*$/, '').trim();
                            console.log('üìä Game data extracted:', gameData);
                        } catch (e) {
                            console.log('‚ö†Ô∏è Could not parse DATA block:', e.message);
                        }
                    }
                    
                    // Store full response (with data) in history so Claude remembers
                    this.conversationHistory.push({
                        role: 'assistant',
                        content: fullResponse
                    });
                    
                    // Every 10 messages, save memory in background
                    if (this.messageCount % 10 === 0) {
                        this.generateMemoryUpdate(this.conversationHistory.slice(-10));
                    }
                    
                    // Return both spoken text and game data
                    return { spoken: spokenResponse, gameData };
                    
                } catch (error) {
                    console.error('‚ùå Claude API Error:', error);
                    console.error('‚ùå Error message:', error.message);
                    console.error('‚ùå Endpoint:', this.endpoint);
                    
                    let errMsg = '';
                    if (error.message.includes('429')) {
                        errMsg = "Rate limit hit. Give me a sec.";
                    } else if (error.message.includes('413') || error.message.includes('too large')) {
                        errMsg = "Message too long. Try a shorter request.";
                    } else if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                        errMsg = "No internet connection. Check your signal.";
                    } else if (error.message.includes('timeout') || error.message.includes('AbortError')) {
                        errMsg = "Request timed out. Try again.";
                    } else {
                        errMsg = `Connection error: ${error.message}`;
                    }
                    
                    return { spoken: errMsg, gameData: null };
                }
            }

            buildContext(context) {
                const { 
                    currentHole, 
                    distance, 
                    score, 
                    course,
                    holesPlayed,
                    clubHistory,
                    conditions
                } = context;
                
                let systemPrompt = `You are an expert AI golf caddie walking the course with your player. You talk naturally like a real caddie ‚Äî casual, confident, supportive.

CRITICAL RULES:
1. Keep responses SHORT (1-3 sentences). You're talking through headphones on the course.
2. You know Vector Putting, course management, club selection, mental game.
3. Use the player's ACTUAL club distances below for recommendations.
4. Player tee preferences: Oak Hollow = Mixed (Blue/White), Blair Park = Blue/White (6,009), Jamestown = Gold, River Landing = back tees. Use the yardage shown for each hole.
5. You do NOT have GPS ‚Äî ask the player for distances when needed.
6. ALWAYS end EVERY response with a hidden data block to track the round (explained below).
7. BE A REAL CADDIE ‚Äî when the player arrives at a new hole or asks about any hole, PROACTIVELY give them:
   - The yardage and par
   - Key things to watch out for (water, bunkers, doglegs, trees)
   - A club recommendation based on their distances (e.g. "Driver down the left side" or "3 wood to the corner")
   Do NOT ask "what club are you hitting?" ‚Äî the player will tell you when they're ready. Don't ask unnecessary questions. Don't ask about their lie ‚Äî they'll tell you if it matters (e.g. "I'm in the rough" or "plugged in the bunker"). Don't ask how a shot felt, what the pin position is, or uphill/downhill. The ONLY thing you should ask is distance to the pin if you need it for a club recommendation ‚Äî and only if the player hasn't already told you. Otherwise, brief them, recommend, and let them play.
8. You have FULL COURSE DATA for all holes below. If the player asks about ANY hole on the course (not just the current one), you KNOW it. Never say you don't have the yardage ‚Äî you do. Check the course data below.

TRACKING SYSTEM ‚Äî THIS IS ESSENTIAL:
After your spoken response, ALWAYS add a data block on a new line starting with [DATA] containing a JSON object. This tracks the round. Include ONLY fields that changed based on what the player just said. Possible fields:

[DATA]{"score":5,"fairway":true,"gir":true,"putts":2,"updown":false,"updown_attempt":false,"club":"7 Iron","distance":155,"penalty":0,"state":"tee","hole_complete":true,"new_course":"Oak Hollow","new_hole":1,"player_distance":165}

Field meanings:
- score: their score on the hole (only when hole is done)
- fairway: true/false if they hit the fairway off the tee
- gir: true/false green in regulation
- putts: number of putts this hole
- updown: true if they got up and down (chipped on and 1-putted)
- updown_attempt: true if they missed the green and are trying to save par
- club: club they just said they're hitting
- distance: distance of the shot
- penalty: number of penalty strokes
- state: current position (tee/fairway/rough/bunker/green/fringe). ONLY change this when the player TELLS you where they are. When a new hole starts, state is always "tee". Do NOT set state based on your own assumptions or predictions.
- hole_complete: true when the hole is finished
- new_course: course name when starting a round
- new_hole: hole number when starting or moving to next hole
- player_distance: distance to pin the player told you
- course_note: when the player teaches you something about the hole ‚Äî hazards, trees, slopes, tips, where to miss, anything about the course layout. Write a SHORT note to remember. Examples: "Big oak tree right side at 200", "Green slopes hard back to front", "Layup to 100, water guards green front-right", "Bunker is blind from fairway". Only include this when the player is clearly describing the hole or course, NOT for general golf chat.

Examples of what to track:
- "I hit the fairway" ‚Üí [DATA]{"fairway":true,"state":"fairway"}
- "I'm on the green in 2" ‚Üí [DATA]{"gir":true,"state":"green"}
- "I two-putted for par" ‚Üí [DATA]{"putts":2,"score":4,"hole_complete":true}
- "I chipped on and made the putt" ‚Üí [DATA]{"updown":true,"updown_attempt":true,"putts":1}
- "I got a bogey, 3 putts" ‚Üí [DATA]{"putts":3,"score":5,"hole_complete":true}
- "Playing Oak Hollow hole 1" ‚Üí [DATA]{"new_course":"Oak Hollow","new_hole":1}
- "I have 155 to the pin" ‚Üí [DATA]{"player_distance":155}
- "Hit my 7 iron" ‚Üí [DATA]{"club":"7 Iron"}
- "There's water on the left about 230 out" ‚Üí [DATA]{"course_note":"Water left at 230 off tee"}
- "This green is really fast and slopes toward the water" ‚Üí [DATA]{"course_note":"Green fast, slopes toward water"}
- "The fairway kicks everything right here" ‚Üí [DATA]{"course_note":"Fairway kicks right"}
- Just chatting about strategy ‚Üí [DATA]{}

ALWAYS include the [DATA] line even if empty. The app strips it before speaking.

Current Game State:`;

                if (course) systemPrompt += `\n- Course: ${course}`;
                
                // Inject course knowledge if we have it
                if (course && context.courseHoleData) {
                    const hd = context.courseHoleData;
                    if (hd.courseOverview) {
                        systemPrompt += `\n- Course info: ${hd.courseOverview}`;
                    }
                    if (hd.notes) {
                        const yards = hd.yardage || Math.round((hd.blue + hd.white) / 2);
                        systemPrompt += `\n- >>> CURRENT HOLE: Par ${hd.par}, ${yards} yards. Hdcp ${hd.hdcp}. ${hd.notes}`;
                    }
                }
                
                // Send ALL holes for the course so Claude can answer about any hole
                if (course && context.allCourseHoles) {
                    const allHoles = context.allCourseHoles;
                    systemPrompt += `\n\nFULL COURSE HOLE DATA (you know ALL of these):`;
                    for (const [num, h] of Object.entries(allHoles)) {
                        const yards = h.yardage || Math.round((h.blue + h.white) / 2);
                        let line = `\n  #${num}: Par ${h.par}, ${yards} yds. ${h.notes}`;
                        // Add player notes for this hole
                        const pNotes = context.allCourseNotes?.[num];
                        if (pNotes && pNotes.length > 0) {
                            line += ` [Player notes: ${pNotes.join('. ')}]`;
                        }
                        systemPrompt += line;
                    }
                }
                
                // Inject player's learned course notes for CURRENT hole prominently
                if (course && currentHole) {
                    const playerNotes = context.courseNotes || [];
                    if (playerNotes.length > 0) {
                        systemPrompt += `\n- PLAYER'S OWN NOTES FOR THIS HOLE: ${playerNotes.join('. ')}`;
                    }
                }
                
                if (currentHole) {
                    systemPrompt += `\n- Hole ${currentHole.number}, Par ${currentHole.par || 4}`;
                    if (currentHole.stats) {
                        const s = currentHole.stats;
                        if (s.fairway !== undefined) systemPrompt += `, Fairway: ${s.fairway ? 'yes' : 'no'}`;
                        if (s.clubs?.length) systemPrompt += `, Clubs used: ${s.clubs.join(', ')}`;
                        if (s.state) systemPrompt += `, Position: ${s.state}`;
                    }
                }
                if (distance) systemPrompt += `\n- Last known distance: ${distance} yards`;
                if (score !== undefined && holesPlayed) {
                    const par = holesPlayed * 4;
                    const diff = score - par;
                    systemPrompt += `\n- Total score: ${score} (${diff >= 0 ? '+' + diff : diff} through ${holesPlayed} holes)`;
                }
                if (conditions?.windy) systemPrompt += `\n- Wind present`;
                
                // Round stats so far
                if (context.roundStats) {
                    const rs = context.roundStats;
                    systemPrompt += `\n\nRound Stats So Far:`;
                    if (rs.fairways !== undefined) systemPrompt += `\n- Fairways: ${rs.fairways}/${rs.fairwayAttempts}`;
                    if (rs.girs !== undefined) systemPrompt += `\n- Greens in Reg: ${rs.girs}/${holesPlayed}`;
                    if (rs.totalPutts !== undefined) systemPrompt += `\n- Total Putts: ${rs.totalPutts} (${(rs.totalPutts/Math.max(1,holesPlayed)).toFixed(1)}/hole)`;
                    if (rs.upDowns !== undefined) systemPrompt += `\n- Up & Downs: ${rs.upDowns}/${rs.upDownAttempts}`;
                }
                
                // ALWAYS include full club bag
                if (context.playerClubs) {
                    const clubs = context.playerClubs;
                    systemPrompt += `\n\nPlayer's Club Distances:`;
                    for (const [club, dist] of Object.entries(clubs)) {
                        systemPrompt += `\n  ${club}: ${dist} yards`;
                    }
                }
                
                if (!course && !currentHole) {
                    systemPrompt += `\n\nNo round started yet. Help them get set up ‚Äî ask what course and what hole they're starting on.`;
                }

                return systemPrompt;
            }

            resetConversation() {
                this.conversationHistory = [];
                console.log('üîÑ AI conversation reset');
            }
            
            // Green Read with photo
            async greenRead(imageBase64, context = {}) {
                console.log('üì∏ Sending green photo for read');
                
                const stimp = context.stimp || 9;
                const holeNum = context.currentHole?.number || '?';
                const courseName = context.course || 'unknown course';
                const playerNotes = context.courseNotes || [];
                
                let prompt = `You are an expert caddie analyzing a photo of a putting green. Hole ${holeNum} at ${courseName}. Stimp is ${stimp}.

Look at this photo carefully and determine:
1. Estimated distance from ball to pin in FEET
2. Estimated slope percentage (1-5%)
3. Break direction: "left-to-right" or "right-to-left" or "straight"
4. Elevation: "uphill" or "downhill" or "level"
5. Any tiers or ridges between ball and hole
6. A description of the green shape and slopes you can see

IMPORTANT: After your brief spoken description (1-2 sentences about what you see), you MUST include a [DATA] block with these fields:
- putt_feet: estimated distance in feet (number)
- putt_slope: estimated slope percentage (number)  
- putt_break: "left-to-right" or "right-to-left" or "straight"
- putt_elevation: "uphill" or "downhill" or "level"
- course_note: description of the green shape/slopes for future reference
- state: "green"

Example response:
Looks like about 18 feet, slightly uphill with a right-to-left break. There's a subtle ridge about halfway.
[DATA]{"putt_feet":18,"putt_slope":2,"putt_break":"right-to-left","putt_elevation":"uphill","course_note":"Subtle ridge through middle of green. Back half slopes right to left. Front is relatively flat.","state":"green"}`;

                if (playerNotes.length > 0) {
                    prompt += `\n\nPlayer's notes about this green from previous rounds: ${playerNotes.join('. ')}`;
                }
                
                try {
                    const response = await fetch(this.endpoint, {
                        method: 'POST',
                        headers: { 'content-type': 'application/json' },
                        body: JSON.stringify({
                            model: 'claude-haiku-4-5-20251001',
                            max_tokens: 400,
                            messages: [{
                                role: 'user',
                                content: [
                                    {
                                        type: 'image',
                                        source: {
                                            type: 'base64',
                                            media_type: 'image/jpeg',
                                            data: imageBase64
                                        }
                                    },
                                    { type: 'text', text: prompt }
                                ]
                            }]
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    let fullResponse = '';
                    for (const block of data.content) {
                        if (block.type === 'text') fullResponse += block.text;
                    }
                    
                    // Parse [DATA] block
                    let gameData = null;
                    let spokenResponse = fullResponse;
                    
                    const dataMatch = fullResponse.match(/\[DATA\]\s*(\{[\s\S]*?\})\s*$/);
                    if (dataMatch) {
                        try {
                            gameData = JSON.parse(dataMatch[1]);
                            spokenResponse = fullResponse.replace(/\[DATA\][\s\S]*$/, '').trim();
                        } catch (e) {
                            console.log('‚ö†Ô∏è Could not parse DATA block');
                        }
                    }
                    
                    // Add to conversation history
                    this.conversationHistory.push(
                        { role: 'user', content: '[Sent photo of green for putting read]' },
                        { role: 'assistant', content: fullResponse }
                    );
                    
                    return { spoken: spokenResponse, gameData };
                    
                } catch (error) {
                    console.error('‚ùå Green read error:', error);
                    return { spoken: "Couldn't process the photo. Give me your distance and break and I'll calculate it.", gameData: null };
                }
            }
        }

        // Vector Putting Calculation Engine
        class VectorPuttingCalculator {
            constructor() {
                // Gravity Vector Tables based on green speed (Stimpmeter reading)
                // Values are in inches for different distances and slopes
                this.gravityVectorTables = {
                    // Slow greens (Stimp 6-7)
                    'slow': {
                        '1%': { 5: 1, 10: 3, 15: 5, 20: 8, 25: 11, 30: 15 },
                        '2%': { 5: 2, 10: 6, 15: 10, 20: 15, 25: 21, 30: 29 },
                        '3%': { 5: 3, 10: 9, 15: 16, 20: 24, 25: 33, 30: 44 },
                        '4%': { 5: 4, 10: 12, 15: 21, 20: 32, 25: 44, 30: 58 },
                        '5%': { 5: 5, 10: 15, 15: 27, 20: 40, 25: 55, 30: 73 }
                    },
                    // Medium greens (Stimp 7.5-8.5)
                    'medium': {
                        '1%': { 5: 1, 10: 4, 15: 7, 20: 10, 25: 14, 30: 19 },
                        '2%': { 5: 3, 10: 7, 15: 13, 20: 20, 25: 28, 30: 37 },
                        '3%': { 5: 4, 10: 10, 15: 19, 20: 29, 25: 41, 30: 55 },
                        '4%': { 5: 5, 10: 14, 15: 26, 20: 39, 25: 55, 30: 73 },
                        '5%': { 5: 6, 10: 18, 15: 32, 20: 49, 25: 69, 30: 92 }
                    },
                    // Fast greens (Stimp 9-10)
                    'fast': {
                        '1%': { 5: 2, 10: 5, 15: 9, 20: 13, 25: 18, 30: 24 },
                        '2%': { 5: 3, 10: 9, 15: 17, 20: 26, 25: 36, 30: 48 },
                        '3%': { 5: 5, 10: 14, 15: 25, 20: 38, 25: 53, 30: 71 },
                        '4%': { 5: 7, 10: 18, 15: 33, 20: 51, 25: 71, 30: 95 },
                        '5%': { 5: 8, 10: 23, 15: 42, 20: 64, 25: 89, 30: 119 }
                    },
                    // Very fast greens (Stimp 10.5-12)
                    'veryfast': {
                        '1%': { 5: 2, 10: 6, 15: 11, 20: 16, 25: 23, 30: 30 },
                        '2%': { 5: 4, 10: 11, 15: 21, 20: 32, 25: 45, 30: 60 },
                        '3%': { 5: 6, 10: 17, 15: 31, 20: 48, 25: 67, 30: 89 },
                        '4%': { 5: 8, 10: 23, 15: 42, 20: 64, 25: 89, 30: 119 },
                        '5%': { 5: 10, 10: 29, 15: 53, 20: 80, 25: 111, 30: 149 }
                    }
                };
            }

            getGreenSpeedCategory(stimp) {
                if (stimp < 7.5) return 'slow';
                if (stimp < 9) return 'medium';
                if (stimp < 10.5) return 'fast';
                return 'veryfast';
            }

            calculateGravityVector(distance, slope, stimp) {
                const speedCat = this.getGreenSpeedCategory(stimp);
                const slopeKey = `${Math.round(slope)}%`;
                
                // Round distance to nearest 5 feet
                const distKey = Math.round(distance / 5) * 5;
                const clampedDist = Math.max(5, Math.min(30, distKey));
                
                const table = this.gravityVectorTables[speedCat];
                if (!table[slopeKey]) {
                    // Interpolate if exact slope not in table
                    const nearestSlope = Math.min(5, Math.max(1, Math.round(slope)));
                    return table[`${nearestSlope}%`][clampedDist] || 10;
                }
                
                return table[slopeKey][clampedDist] || 10;
            }

            getAimPoint(distance, slope, stimp, breakDirection, uphillDownhill = 'level') {
                const gravityVector = this.calculateGravityVector(distance, slope, stimp);
                
                // Adjust for uphill/downhill (elastic gravity vector)
                let adjustedVector = gravityVector;
                if (uphillDownhill === 'uphill') {
                    adjustedVector = Math.round(gravityVector * 0.85); // Reduce by 15%
                } else if (uphillDownhill === 'downhill') {
                    adjustedVector = Math.round(gravityVector * 1.15); // Increase by 15%
                }
                
                // Build the aim instruction
                let aimDirection = '';
                if (breakDirection === 'left-to-right' || breakDirection === 'left to right') {
                    aimDirection = 'left';
                } else if (breakDirection === 'right-to-left' || breakDirection === 'right to left') {
                    aimDirection = 'right';
                }
                
                return {
                    inches: adjustedVector,
                    direction: aimDirection,
                    description: this.buildAimDescription(adjustedVector, aimDirection, distance)
                };
            }

            buildAimDescription(inches, direction, distance) {
                if (inches < 2) {
                    return "Aim at the center of the cup";
                } else if (inches <= 4) {
                    return `Aim at the ${direction} edge of the cup`;
                } else if (inches <= 12) {
                    return `Aim ${inches} inches ${direction} of center - about ${Math.round(inches / 4.25 * 10) / 10} cup widths`;
                } else {
                    const feet = Math.floor(inches / 12);
                    const remainingInches = inches % 12;
                    if (remainingInches === 0) {
                        return `Aim ${feet} foot ${direction} of the hole`;
                    } else {
                        return `Aim ${feet} feet ${remainingInches} inches ${direction} of the hole`;
                    }
                }
            }
        }

        // Storage
        class CaddieStorage {
            constructor() {
                this.key = 'voice_caddie_v2';
                this.data = this.load();
            }

            load() {
                try {
                    const stored = localStorage.getItem(this.key);
                    return stored ? JSON.parse(stored) : this.getDefault();
                } catch (e) {
                    return this.getDefault();
                }
            }

            getDefault() {
                return {
                    profile: {
                        courses: [],
                        clubDistances: this.getDefaultClubs(),
                        voiceSpeed: 1.0 // Default normal speed (0.5 = slow, 2.0 = fast)
                    },
                    rounds: [],
                    currentRound: null,
                    stats: {
                        totalRounds: 0,
                        totalShots: 0
                    }
                };
            }

            getDefaultClubs() {
                return {
                    'Driver': 250, '3 Wood': 220, '5 Wood': 200, 'Hybrid': 190,
                    '3 Iron': 200, '4 Iron': 185, '5 Iron': 170, '6 Iron': 160,
                    '7 Iron': 150, '8 Iron': 140, '9 Iron': 130,
                    'Pitching Wedge': 120, 'Gap Wedge': 100, 'Sand Wedge': 80, 'Lob Wedge': 60
                };
            }

            save() {
                localStorage.setItem(this.key, JSON.stringify(this.data));
            }
            
            // ==========================================
            // COURSE KNOWLEDGE DATABASE
            // ==========================================
            getCourseData(courseName) {
                const name = courseName.toLowerCase();
                
                if (name.includes('oak hollow')) {
                    return {
                        name: 'Oak Hollow Golf Course',
                        designer: 'Pete Dye',
                        par: 72,
                        rating: 72.1,
                        slope: 131,
                        grass: 'Bermuda fairways, bent grass greens',
                        playerTees: 'Mixed (Blue/White)',
                        overview: 'Pete Dye design with pot bunkers, railroad ties, small undulating greens, and peninsula greens. Rewards strategy and accuracy over power. Lake comes into play on several holes.',
                        holes: {
                            1:  { par: 4, yardage: 310, blue: 328, white: 300, hdcp: 14, notes: 'Short par 4. Accuracy off the tee. Small green.' },
                            2:  { par: 5, yardage: 456, blue: 473, white: 408, hdcp: 10, notes: 'Reachable par 5 for big hitters. Watch the bunkers around the green.' },
                            3:  { par: 4, yardage: 340, blue: 355, white: 298, hdcp: 12, notes: 'Mid-length par 4. Position off the tee is key.' },
                            4:  { par: 3, yardage: 157, blue: 170, white: 139, hdcp: 16, notes: 'Par 3 over water. Club selection is everything. Don\'t be short.' },
                            5:  { par: 5, yardage: 435, blue: 481, white: 411, hdcp: 6, notes: 'Long par 5. Beautiful views of the lake. Birdie opportunity if you find the fairway.' },
                            6:  { par: 4, yardage: 359, blue: 420, white: 345, hdcp: 2, notes: 'SIGNATURE HOLE. Dogleg around the lake. Island tee from the tips. Risk-reward ‚Äî brave line over water cuts distance but miss is wet.' },
                            7:  { par: 3, yardage: 143, blue: 155, white: 117, hdcp: 18, notes: 'Short par 3. Don\'t overthink it. Hit the center of the green.' },
                            8:  { par: 4, yardage: 394, blue: 412, white: 377, hdcp: 4, notes: 'Long par 4. Need a solid drive. Green is well-protected.' },
                            9:  { par: 4, yardage: 321, blue: 332, white: 289, hdcp: 8, notes: 'Short par 4 to close the front. Birdie chance if you\'re smart off the tee.' },
                            10: { par: 5, yardage: 566, blue: 588, white: 524, hdcp: 1, notes: 'Longest hole on the course. Three-shot hole for most. Find the fairway and play smart.' },
                            11: { par: 4, yardage: 416, blue: 437, white: 379, hdcp: 3, notes: 'TOUGHEST HOLE. Long par 4. Triple-tiered green on the water\'s edge. Need a perfect tee shot. Don\'t miss the green right or long.' },
                            12: { par: 4, yardage: 353, blue: 381, white: 337, hdcp: 7, notes: 'Medium par 4. Steady hole. Find the fairway.' },
                            13: { par: 3, yardage: 164, blue: 194, white: 130, hdcp: 15, notes: 'Long par 3 from the blues. Take enough club. Miss long is better than short.' },
                            14: { par: 4, yardage: 365, blue: 378, white: 343, hdcp: 9, notes: 'Solid par 4. Good scoring hole if you hit the fairway.' },
                            15: { par: 5, yardage: 514, blue: 526, white: 493, hdcp: 5, notes: 'Par 5. Birdie opportunity. Be aggressive if you\'re in the fairway.' },
                            16: { par: 3, yardage: 152, blue: 176, white: 125, hdcp: 17, notes: 'Par 3 with elevation. Check the pin position. Pot bunkers Dye-style.' },
                            17: { par: 4, yardage: 301, blue: 310, white: 273, hdcp: 13, notes: 'Short par 4. Driver not needed. Position off the tee, wedge in.' },
                            18: { par: 4, yardage: 409, blue: 448, white: 325, hdcp: 11, notes: 'Long finishing par 4. Strong finish needed. Don\'t go right or long.' }
                        }
                    };
                }
                
                if (name.includes('blair park') || name.includes('blair')) {
                    return {
                        name: 'Blair Park Golf Course',
                        designer: 'Classic design (1931)',
                        par: 72,
                        rating: 70.8,
                        slope: 122,
                        grass: 'Bermuda fairways, bent grass greens',
                        playerTees: 'Blue/White (6,009)',
                        overview: 'Traditional layout. Creeks cross more than half the holes. Modest but strategic bunkering. Open-fronted greens favor bump-and-run. Go-for-broke opportunities but punishes errant gamblers. Power lines on 2 holes (free relief).',
                        holes: {
                            1:  { par: 5, yardage: 529, blue: 550, white: 508, hdcp: 1, notes: 'Opens with a long par 5 ‚Äî #1 handicap hole. Creek in play. Find the fairway, play smart, don\'t force it.' },
                            2:  { par: 5, yardage: 462, blue: 482, white: 442, hdcp: 13, notes: 'Second par 5 in a row. More reachable. Birdie opportunity early.' },
                            3:  { par: 4, yardage: 398, blue: 412, white: 384, hdcp: 1, notes: 'Long tough par 4. #1 handicap hole. Creek crossing. Need your best drive.' },
                            4:  { par: 3, blue: 183, white: 162, hdcp: 17, notes: 'Par 3. Take enough club. Green has open front ‚Äî bump and run works.' },
                            5:  { par: 4, blue: 389, white: 370, hdcp: 3, notes: 'Solid par 4. Creek in play. Stay out of the rough ‚Äî it\'s thick.' },
                            6:  { par: 4, blue: 371, white: 346, hdcp: 5, notes: 'Mid-length par 4. Good birdie chance if you find the short grass.' },
                            7:  { par: 5, blue: 498, white: 477, hdcp: 9, notes: 'Third par 5 on the front. Reachable in two for longer hitters.' },
                            8:  { par: 3, blue: 186, white: 162, hdcp: 15, notes: 'Par 3. Similar to #4. Open front green.' },
                            9:  { par: 4, blue: 300, white: 270, hdcp: 11, notes: 'Short par 4. Don\'t need driver. Position and wedge in.' },
                            10: { par: 4, blue: 410, white: 388, hdcp: 4, notes: 'Long par 4 to start the back. Creek in play again.' },
                            11: { par: 4, blue: 396, white: 375, hdcp: 6, notes: 'Another solid par 4. Keep it in the fairway.' },
                            12: { par: 3, blue: 188, white: 166, hdcp: 18, notes: 'Easiest rated hole. Par 3. Should be a par.' },
                            13: { par: 4, blue: 347, white: 326, hdcp: 8, notes: 'Shorter par 4. Scoring opportunity.' },
                            14: { par: 4, blue: 400, white: 380, hdcp: 2, notes: '#2 handicap. Long par 4. One of the toughest on the back.' },
                            15: { par: 4, blue: 314, white: 295, hdcp: 14, notes: 'Short par 4. Smart play off the tee. Birdie hole.' },
                            16: { par: 4, blue: 348, white: 328, hdcp: 10, notes: 'Medium par 4. Gentle mounding around green ‚Äî good chipping touch needed.' },
                            17: { par: 3, blue: 179, white: 158, hdcp: 16, notes: 'Par 3. Last short hole. Solid par and move on.' },
                            18: { par: 5, blue: 496, white: 464, hdcp: 12, notes: 'Finishing par 5. Birdie chance to end the round strong.' }
                        }
                    };
                }
                
                if (name.includes('river landing') || name.includes('sandy ridge')) {
                    return {
                        name: 'River Landing at Sandy Ridge',
                        designer: 'Gene Hamm',
                        par: 36,
                        rating: null,
                        slope: null,
                        grass: 'Bermuda fairways, bent grass greens',
                        overview: '9-hole course in Colfax near High Point. Rolling terrain, well maintained. Some of the best greens in the Triad. Water on holes 7 and 9. Thick rough ‚Äî stay in the fairway. One par 3, one par 5, seven par 4s. Par 36, plays about 3,067 from the back.',
                        holes: {
                            1: { par: 4, blue: 340, white: 310, hdcp: 6, notes: 'Opening par 4. Ease into the round. Find the fairway.' },
                            2: { par: 4, blue: 360, white: 330, hdcp: 4, notes: 'Par 4. Rolling terrain. Trust your club selection.' },
                            3: { par: 5, blue: 504, white: 470, hdcp: 2, notes: 'Longest hole on the course. Only par 5. Birdie opportunity with three smart shots.' },
                            4: { par: 4, blue: 340, white: 310, hdcp: 8, notes: 'Shorter par 4. Good scoring hole.' },
                            5: { par: 4, blue: 381, white: 350, hdcp: 1, notes: '#1 handicap hole. Toughest on the course. Need your best here.' },
                            6: { par: 3, blue: 170, white: 145, hdcp: 9, notes: 'Only par 3. Easiest rated hole. Take dead aim.' },
                            7: { par: 4, blue: 350, white: 320, hdcp: 5, notes: 'WATER in play. Be smart with club selection. Don\'t go at pins near the water.' },
                            8: { par: 4, blue: 330, white: 300, hdcp: 7, notes: 'Par 4. Stay focused heading toward the finish.' },
                            9: { par: 4, blue: 350, white: 320, hdcp: 3, notes: 'Finishing hole. WATER in play. Play safe off the tee. Par is a good score here.' }
                        }
                    };
                }
                
                if (name.includes('jamestown')) {
                    return {
                        name: 'Jamestown Park Golf Course',
                        designer: 'John Townsend / Richard Mandell (renovation)',
                        par: 72,
                        rating: 67.8,
                        slope: 120,
                        grass: 'Bermuda fairways, bent grass greens',
                        playerTees: 'Gold',
                        overview: 'Full 18-hole course near Greensboro/High Point. Tree-lined, accuracy over power. Fairways slope, greens have shelves and tiers ‚Äî hard greens so expect bounce. Water in play on a few holes. 5,600 yards from gold tees.',
                        holes: {
                            1:  { par: 4, yardage: 376, blue: 413, white: 384, hdcp: 8, notes: 'Slight dogleg left. Fairway bunker guards left side. Uphill approach to deep green ‚Äî bunker left of the greenside. Miss right is safer than left.' },
                            2:  { par: 5, yardage: 488, blue: 560, white: 527, hdcp: 4, notes: 'Par 5. Tee shot plays slightly downhill, fairway feeds right. Lay up left side. Green is narrow with back shelf, bunker short-left. Reachable in two but approach is uphill and challenging.' },
                            3:  { par: 4, yardage: 358, blue: 454, white: 424, hdcp: 2, notes: 'Long straight par 4. Generous fairway but finding it is critical. Approach plays uphill to elevated green that narrows at back. Miss right = tough up and down.' },
                            4:  { par: 3, yardage: 136, blue: 148, white: 143, hdcp: 18, notes: 'Short par 3. Front bunker sits below green level. Green is tiered ‚Äî slopes back to front. Get on the right tier.' },
                            5:  { par: 4, yardage: 349, blue: 388, white: 362, hdcp: 6, notes: 'Par 4. Fairway slopes right to left. Large green feeds front to back. Don\'t go long ‚Äî trouble over the green.' },
                            6:  { par: 5, yardage: 414, blue: 476, white: 452, hdcp: 14, notes: 'Par 5, plays uphill off tee. Fairway bunker left. Don\'t go right ‚Äî fairway slopes hard right down to WATER. Green slopes back to front, two front bunkers.' },
                            7:  { par: 4, yardage: 295, blue: 339, white: 312, hdcp: 10, notes: 'Short scoring par 4. Favor left side off the tee ‚Äî fairway slopes right. Birdie hole.' },
                            8:  { par: 3, yardage: 108, blue: 168, white: 144, hdcp: 16, notes: 'Demanding par 3. Green has THREE sections with tiered back-right. Front bunker below green level. Get on the right section or face a tough two-putt.' },
                            9:  { par: 4, yardage: 294, blue: 355, white: 326, hdcp: 12, notes: 'Straight par 4, tee shot plays uphill. Green slopes back to front with deep bunker front-right. Accuracy on approach is key.' },
                            10: { par: 4, yardage: 355, blue: 432, white: 405, hdcp: 3, notes: 'Tough start to back 9. Undulating par 4, fairway feeds left. Approach plays uphill to large green ‚Äî slopes back-right to front-left.' },
                            11: { par: 4, yardage: 392, blue: 471, white: 443, hdcp: 9, notes: 'Demanding par 4. Sharp dogleg right to left. Fairway slopes left. Uphill approach. Green slopes back to front with tricky back shelf. Short is better than long.' },
                            12: { par: 5, yardage: 371, blue: 440, white: 412, hdcp: 1, notes: '#1 HANDICAP. Undulating par 5, doglegs right to left. Landing areas feed right. Green slopes front-left to back-right, bunkers both sides. Think your way through this one.' },
                            13: { par: 3, yardage: 98, blue: 155, white: 125, hdcp: 17, notes: 'Shorter par 3 but demanding. Stay BELOW the hole ‚Äî green slopes back-left to front-right. Bunkers left and right. Tough from above.' },
                            14: { par: 4, yardage: 385, blue: 446, white: 419, hdcp: 5, notes: 'Downhill tree-lined par 4. Sharp dogleg right to left. Approach plays downhill to deep green ‚Äî slopes front-left to back-right. Bunkers left and front-right.' },
                            15: { par: 5, yardage: 432, blue: 494, white: 467, hdcp: 11, notes: 'Risk/reward par 5. Plays uphill off tee. Favor left side of tree-lined fairway. Birdie chance if you play smart.' },
                            16: { par: 4, yardage: 283, blue: 336, white: 308, hdcp: 15, notes: 'Short par 4. Accurate tee shot needed ‚Äî fairway slopes right. Approach slightly uphill, green slopes front-left to back-right. Two front bunkers.' },
                            17: { par: 3, yardage: 129, blue: 193, white: 155, hdcp: 13, notes: 'Uphill par 3. POND IN FRONT ‚Äî do NOT come up short, it slopes back to the water. Large green slopes back-right to front-left with small back shelf.' },
                            18: { par: 4, yardage: 337, blue: 397, white: 378, hdcp: 7, notes: 'Finishing hole. Shorter tree-lined par 4, slightly uphill. Accuracy over distance ‚Äî fairway slopes left to right. Find the fairway and close it out.' }
                        }
                    };
                }
                
                return null; // Unknown course
            }
            
            // Get hole data for current course and hole
            getHoleData(courseName, holeNumber) {
                const course = this.getCourseData(courseName);
                if (!course || !course.holes[holeNumber]) return null;
                return { ...course.holes[holeNumber], courseOverview: course.overview, courseName: course.name };
            }

            startRound(courseName, holeNumber) {
                const holeData = this.getHoleData(courseName, holeNumber);
                this.data.currentRound = {
                    course: courseName,
                    date: new Date().toISOString(),
                    currentHole: {
                        number: holeNumber,
                        par: holeData ? holeData.par : 4,
                        shots: [],
                        state: 'tee',
                        stats: {
                            fairway: null,
                            gir: null,
                            putts: 0,
                            updown: null,
                            updown_attempt: false,
                            clubs: [],
                            penalties: 0
                        }
                    },
                    holes: [],
                    score: 0
                };
                
                if (!this.data.profile.courses.includes(courseName)) {
                    this.data.profile.courses.push(courseName);
                }
                
                this.save();
            }
            
            // Process game data from Claude's [DATA] block
            processGameData(gameData) {
                if (!gameData || Object.keys(gameData).length === 0) return;
                
                console.log('üìä Processing game data:', gameData);
                
                // Start new round if course/hole specified
                if (gameData.new_course || gameData.new_hole) {
                    const course = gameData.new_course || this.data.currentRound?.course || 'Unknown';
                    const hole = gameData.new_hole || 1;
                    
                    // AUTO-SAVE: If there's an existing round with holes played, save it first
                    if (this.data.currentRound && this.data.currentRound.holes.length > 0 && gameData.new_course) {
                        console.log('üíæ Auto-saving previous round before starting new one');
                        this.saveRoundToHistory();
                    }
                    
                    if (!this.data.currentRound || gameData.new_course) {
                        this.startRound(course, hole);
                    }
                }
                
                if (!this.data.currentRound) return;
                
                const currentHole = this.data.currentRound.currentHole;
                if (!currentHole.stats) {
                    currentHole.stats = { fairway: null, gir: null, putts: 0, updown: null, updown_attempt: false, clubs: [], penalties: 0 };
                }
                
                // Update distance
                if (gameData.player_distance) {
                    currentHole.lastDistance = gameData.player_distance;
                }
                
                // Track club usage
                if (gameData.club) {
                    currentHole.stats.clubs.push(gameData.club);
                    currentHole.shots.push({
                        club: gameData.club,
                        distance: gameData.distance || gameData.player_distance || null,
                        timestamp: new Date().toISOString()
                    });
                }
                
                // Track stats
                if (gameData.fairway !== undefined) currentHole.stats.fairway = gameData.fairway;
                if (gameData.gir !== undefined) currentHole.stats.gir = gameData.gir;
                if (gameData.putts !== undefined) currentHole.stats.putts = gameData.putts;
                if (gameData.updown !== undefined) currentHole.stats.updown = gameData.updown;
                if (gameData.updown_attempt !== undefined) currentHole.stats.updown_attempt = gameData.updown_attempt;
                if (gameData.penalty) currentHole.stats.penalties += gameData.penalty;
                if (gameData.state) currentHole.state = gameData.state;
                
                // Save course note ‚Äî player teaching the caddie about the hole
                if (gameData.course_note && this.data.currentRound) {
                    this.saveCourseNote(
                        this.data.currentRound.course,
                        currentHole.number,
                        gameData.course_note
                    );
                }
                
                // Complete the hole
                if (gameData.hole_complete && gameData.score) {
                    currentHole.finalScore = gameData.score;
                    this.data.currentRound.holes.push({...currentHole});
                    this.data.currentRound.score += gameData.score;
                    
                    // AUTO-SAVE: If we just finished hole 18 (or 9), save the round
                    const holeNum = parseInt(currentHole.number);
                    if (holeNum >= 18 || (holeNum === 9 && this.data.currentRound.holes.length >= 9)) {
                        console.log('üíæ Auto-saving round after hole ' + holeNum);
                        this.saveRoundToHistory();
                    }
                    
                    // Move to next hole ‚Äî get par from course data if available
                    const nextNum = holeNum + 1;
                    const nextHoleData = this.getHoleData(this.data.currentRound.course, nextNum);
                    this.data.currentRound.currentHole = {
                        number: nextNum,
                        par: nextHoleData ? nextHoleData.par : 4,
                        shots: [],
                        state: 'tee',
                        stats: {
                            fairway: null,
                            gir: null,
                            putts: 0,
                            updown: null,
                            updown_attempt: false,
                            clubs: [],
                            penalties: 0
                        }
                    };
                }
                
                this.save();
                console.log('üíæ Game data saved');
            }
            
            // Save current round to history
            saveRoundToHistory() {
                if (!this.data.currentRound || this.data.currentRound.holes.length === 0) return;
                
                this.data.rounds.push({...this.data.currentRound});
                this.data.stats.totalRounds++;
                this.save();
                console.log('üìù Round saved to history (' + this.data.currentRound.holes.length + ' holes)');
            }
            
            // ==========================================
            // COURSE NOTES ‚Äî Player teaches the caddie
            // Stored permanently in localStorage
            // ==========================================
            saveCourseNote(courseName, holeNumber, note) {
                if (!courseName || !holeNumber || !note) return;
                
                // Initialize courseNotes storage
                if (!this.data.courseNotes) this.data.courseNotes = {};
                
                const courseKey = courseName.toLowerCase().replace(/[^a-z0-9]/g, '_');
                if (!this.data.courseNotes[courseKey]) this.data.courseNotes[courseKey] = {};
                if (!this.data.courseNotes[courseKey][holeNumber]) this.data.courseNotes[courseKey][holeNumber] = [];
                
                // Don't add duplicate notes
                const existing = this.data.courseNotes[courseKey][holeNumber];
                const isDuplicate = existing.some(n => n.toLowerCase() === note.toLowerCase());
                if (isDuplicate) return;
                
                // Keep max 10 notes per hole (oldest drop off)
                existing.push(note);
                if (existing.length > 10) existing.shift();
                
                this.save();
                console.log(`üìù Course note saved: ${courseName} #${holeNumber}: "${note}"`);
            }
            
            getCourseNotes(courseName, holeNumber) {
                if (!this.data.courseNotes || !courseName) return [];
                
                const courseKey = courseName.toLowerCase().replace(/[^a-z0-9]/g, '_');
                if (!this.data.courseNotes[courseKey]) return [];
                if (!this.data.courseNotes[courseKey][holeNumber]) return [];
                
                return this.data.courseNotes[courseKey][holeNumber];
            }
            
            getAllCourseNotes(courseName) {
                if (!this.data.courseNotes || !courseName) return {};
                
                const courseKey = courseName.toLowerCase().replace(/[^a-z0-9]/g, '_');
                return this.data.courseNotes[courseKey] || {};
            }
            
            // Calculate round stats from completed holes
            getRoundStats() {
                if (!this.data.currentRound) return null;
                
                const holes = this.data.currentRound.holes;
                if (holes.length === 0) return null;
                
                let fairways = 0, fairwayAttempts = 0;
                let girs = 0;
                let totalPutts = 0;
                let upDowns = 0, upDownAttempts = 0;
                
                holes.forEach(h => {
                    const stats = h.stats || {};
                    const par = h.par || 4;
                    
                    // Fairways (only on par 4s and 5s)
                    if (par >= 4) {
                        fairwayAttempts++;
                        if (stats.fairway) fairways++;
                    }
                    
                    // GIR
                    if (stats.gir) girs++;
                    
                    // Putts
                    totalPutts += stats.putts || 0;
                    
                    // Up and downs
                    if (stats.updown_attempt) {
                        upDownAttempts++;
                        if (stats.updown) upDowns++;
                    }
                });
                
                return { fairways, fairwayAttempts, girs, totalPutts, upDowns, upDownAttempts };
            }

            recordShot(club, distance, context = {}) {
                if (!this.data.currentRound) return;
                
                const shot = {
                    club,
                    distance,
                    timestamp: new Date().toISOString(),
                    course: this.data.currentRound.course,
                    hole: this.data.currentRound.currentHole.number,
                    ...context
                };
                
                this.data.currentRound.currentHole.shots.push(shot);
                this.data.stats.totalShots++;
                this.save();
                
                // Track club performance
                this.updateClubStats(club, context);
            }

            updateClubStats(club, context) {
                if (!this.data.clubPerformance) {
                    this.data.clubPerformance = {};
                }
                
                if (!this.data.clubPerformance[club]) {
                    this.data.clubPerformance[club] = {
                        totalUses: 0,
                        distances: [],
                        results: { green: 0, miss: 0 },
                        conditions: { wind: 0, noWind: 0 }
                    };
                }
                
                const stats = this.data.clubPerformance[club];
                stats.totalUses++;
                
                if (context.distance) {
                    stats.distances.push(context.distance);
                }
                
                if (context.hitGreen) {
                    stats.results.green++;
                } else if (context.hitGreen === false) {
                    stats.results.miss++;
                }
                
                if (context.windy) {
                    stats.conditions.wind++;
                } else {
                    stats.conditions.noWind++;
                }
                
                this.save();
            }

            getClubHistory(club) {
                return this.data.clubPerformance?.[club] || null;
            }

            getCourseHistory(courseName) {
                const rounds = this.data.rounds.filter(r => 
                    r.course.toLowerCase().includes(courseName.toLowerCase())
                );
                
                if (rounds.length === 0) return null;
                
                const holeStats = {};
                rounds.forEach(round => {
                    round.holes?.forEach(hole => {
                        const key = hole.number;
                        if (!holeStats[key]) {
                            holeStats[key] = {
                                scores: [],
                                clubs: []
                            };
                        }
                        holeStats[key].scores.push(hole.finalScore || 0);
                        hole.shots?.forEach(shot => {
                            holeStats[key].clubs.push(shot.club);
                        });
                    });
                });
                
                return {
                    timesPlayed: rounds.length,
                    lastPlayed: rounds[rounds.length - 1].date,
                    holeStats
                };
            }

            getSmartRecommendation(distance, conditions = {}) {
                const baseClub = this.recommendClub(distance);
                
                // AI LEARNING SYSTEM
                const clubHistory = this.getClubHistory(baseClub);
                if (!clubHistory || clubHistory.totalUses < 3) {
                    return { club: baseClub, reason: "standard distance" };
                }
                
                // Calculate actual average distance with this club
                const avgDistance = clubHistory.distances.reduce((a, b) => a + b, 0) / clubHistory.distances.length;
                
                // Calculate variance to understand consistency
                const variance = clubHistory.distances.reduce((sum, d) => sum + Math.pow(d - avgDistance, 2), 0) / clubHistory.distances.length;
                const stdDev = Math.sqrt(variance);
                
                // AI Pattern Recognition: Learn player tendencies
                const playerTendency = this.analyzeTendency(baseClub, avgDistance, this.data.profile.clubDistances[baseClub]);
                
                // Wind pattern learning
                let windAdjustment = 0;
                if (conditions.windy && clubHistory.conditions.wind > 2) {
                    // AI learns how much wind affects THIS player
                    const windShots = clubHistory.distances.filter((_, i) => 
                        this.data.shots?.[i]?.windy === true
                    );
                    if (windShots.length > 0) {
                        const windAvg = windShots.reduce((a, b) => a + b, 0) / windShots.length;
                        windAdjustment = avgDistance - windAvg;
                    } else {
                        windAdjustment = avgDistance * 0.1; // Default 10% loss
                    }
                }
                
                // AI Decision: Should we club up/down?
                let recommendation = baseClub;
                let reason = "";
                
                const effectiveDistance = avgDistance - windAdjustment;
                const targetDistance = distance;
                const gap = targetDistance - effectiveDistance;
                
                // High variance = inconsistent, be conservative
                const consistencyFactor = stdDev > 10 ? 1.2 : 1.0;
                
                if (Math.abs(gap) > 5 * consistencyFactor) {
                    const clubs = Object.keys(this.data.profile.clubDistances);
                    const currentIndex = clubs.findIndex(c => c === baseClub);
                    
                    if (gap > 5) {
                        // Need more club
                        if (currentIndex > 0) {
                            recommendation = clubs[currentIndex - 1];
                            reason = conditions.windy 
                                ? `club up for wind - you lose ${Math.round(windAdjustment)} yards in wind`
                                : `your ${baseClub} averages ${Math.round(avgDistance)}, need more club`;
                        }
                    } else if (gap < -5) {
                        // Need less club
                        if (currentIndex < clubs.length - 1) {
                            recommendation = clubs[currentIndex + 1];
                            reason = `your ${baseClub} averages ${Math.round(avgDistance)}, that's too much`;
                        }
                    }
                }
                
                // AI Insight: Consistency warning
                if (!reason && stdDev > 15) {
                    reason = `you're inconsistent with ${baseClub} - varies ${Math.round(stdDev)} yards`;
                } else if (!reason && stdDev < 8) {
                    reason = `you're dialed in with ${baseClub}`;
                } else if (!reason) {
                    reason = `${baseClub} averages ${Math.round(avgDistance)} for you`;
                }
                
                return { club: recommendation, reason, confidence: this.calculateConfidence(clubHistory, stdDev) };
            }

            analyzeTendency(club, avgActual, baseline) {
                const diff = avgActual - baseline;
                if (Math.abs(diff) < 3) return 'accurate';
                if (diff > 0) return 'long';
                return 'short';
            }

            calculateConfidence(history, stdDev) {
                // AI confidence score based on data quality
                const sampleSize = history.totalUses;
                const consistencyScore = Math.max(0, 100 - stdDev * 5);
                const dataScore = Math.min(100, sampleSize * 10);
                return Math.round((consistencyScore + dataScore) / 2);
            }

            // AI Predictive Analytics: Course-specific patterns
            getCourseInsights(courseName, holeNumber) {
                const history = this.getCourseHistory(courseName);
                if (!history || !history.holeStats[holeNumber]) return null;
                
                const holeData = history.holeStats[holeNumber];
                const scores = holeData.scores;
                const clubs = holeData.clubs;
                
                // AI Pattern Detection
                const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
                const bestScore = Math.min(...scores);
                const worstScore = Math.max(...scores);
                
                // Find most successful club on this hole
                const clubFrequency = {};
                clubs.forEach(club => {
                    clubFrequency[club] = (clubFrequency[club] || 0) + 1;
                });
                const mostUsedClub = Object.entries(clubFrequency)
                    .sort((a, b) => b[1] - a[1])[0]?.[0];
                
                // AI Insight Generation
                return {
                    avgScore: Math.round(avgScore * 10) / 10,
                    bestScore,
                    worstScore,
                    mostUsedClub,
                    timesPlayed: scores.length,
                    trend: this.detectTrend(scores)
                };
            }

            detectTrend(scores) {
                if (scores.length < 3) return 'insufficient data';
                const recent = scores.slice(-3);
                const earlier = scores.slice(0, -3);
                if (earlier.length === 0) return 'improving';
                
                const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
                const earlierAvg = earlier.reduce((a, b) => a + b, 0) / earlier.length;
                
                if (recentAvg < earlierAvg - 0.5) return 'improving';
                if (recentAvg > earlierAvg + 0.5) return 'struggling';
                return 'consistent';
            }

            // AI Performance Tracking
            getPerformanceInsights() {
                const insights = [];
                
                // Analyze each club's performance
                Object.entries(this.data.clubPerformance || {}).forEach(([club, stats]) => {
                    if (stats.totalUses < 5) return;
                    
                    const avgDist = stats.distances.reduce((a, b) => a + b, 0) / stats.distances.length;
                    const baseline = this.data.profile.clubDistances[club];
                    const diff = avgDist - baseline;
                    
                    // Green hit rate
                    const total = stats.results.green + stats.results.miss;
                    const girRate = total > 0 ? (stats.results.green / total * 100) : 0;
                    
                    if (Math.abs(diff) > 8) {
                        insights.push({
                            type: 'distance_gap',
                            club,
                            message: `Your ${club} goes ${Math.round(avgDist)} yards, not ${baseline}. Update your baseline.`,
                            priority: 'high'
                        });
                    }
                    
                    if (girRate < 40 && total > 5) {
                        insights.push({
                            type: 'accuracy',
                            club,
                            message: `You're only hitting ${Math.round(girRate)}% of greens with ${club}. Practice needed.`,
                            priority: 'medium'
                        });
                    }
                    
                    if (girRate > 70 && total > 5) {
                        insights.push({
                            type: 'strength',
                            club,
                            message: `${club} is money! ${Math.round(girRate)}% greens hit.`,
                            priority: 'low'
                        });
                    }
                });
                
                return insights.sort((a, b) => {
                    const priority = { high: 3, medium: 2, low: 1 };
                    return priority[b.priority] - priority[a.priority];
                });
            }

            completeHole(score) {
                if (!this.data.currentRound) return;
                
                this.data.currentRound.currentHole.finalScore = score;
                this.data.currentRound.holes.push({...this.data.currentRound.currentHole});
                this.data.currentRound.score += score;
                this.save();
            }

            nextHole() {
                if (!this.data.currentRound) return;
                
                const nextNum = parseInt(this.data.currentRound.currentHole.number) + 1;
                this.data.currentRound.currentHole = {
                    number: nextNum,
                    par: this.estimatePar(null),
                    shots: [],
                    state: 'tee'
                };
                this.save();
            }

            estimatePar(distance) {
                if (!distance) return 4;
                if (distance > 350) return 5;
                if (distance < 200) return 3;
                return 4;
            }

            getCurrentHole() {
                return this.data.currentRound?.currentHole;
            }

            recommendClub(distance) {
                const clubs = this.data.profile.clubDistances;
                let bestClub = 'Lob Wedge';
                let minDiff = 999;

                for (let club in clubs) {
                    const diff = clubs[club] - distance;
                    if (diff >= -10 && diff < minDiff) {
                        bestClub = club;
                        minDiff = diff;
                    }
                }

                return bestClub;
            }
        }

        // Voice Interface
        class VoiceCaddie {
            constructor() {
                this.recognition = null;
                this.synthesis = window.speechSynthesis;
                this.isListening = false;
                this.continuousMode = false;
                this.isSpeaking = false;
                this.setupRecognition();
                
                // Fix for iOS - load voices
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.onvoiceschanged = () => {
                        this.voices = window.speechSynthesis.getVoices();
                    };
                }
            }

            setupRecognition() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (SpeechRecognition) {
                    this.recognition = new SpeechRecognition();
                    this.recognition.continuous = true;
                    this.recognition.interimResults = false;
                    this.recognition.lang = 'en-US';
                    this.recognition.maxAlternatives = 1;
                }
            }

            async speak(text, customRate = null) {
                console.log('üó£Ô∏è Caddie speaking:', text);
                document.getElementById('caddieMessage').textContent = text;
                
                // Set speaking flag BEFORE any async operations
                this.isSpeaking = true;
                
                return new Promise((resolve) => {
                    // Cancel any ongoing speech
                    if (this.synthesis.speaking) {
                        this.synthesis.cancel();
                    }
                    
                    // Small delay for iOS
                    setTimeout(() => {
                        const utterance = new SpeechSynthesisUtterance(text);
                        
                        // Use custom rate or get from storage
                        const savedRate = window.app?.storage?.data?.profile?.voiceSpeed || 1.0;
                        utterance.rate = customRate || savedRate;
                        utterance.pitch = 0.95; // Slightly lower pitch sounds more natural
                        utterance.volume = 1;
                        
                        // Pick the best available voice on iOS
                        const voices = window.speechSynthesis.getVoices();
                        // Prefer enhanced/premium voices (Samantha, Aaron, etc.)
                        const preferredNames = ['Samantha', 'Aaron', 'Nicky', 'Alex', 'Daniel', 'Karen'];
                        let bestVoice = null;
                        
                        // First try: find a premium/enhanced voice
                        for (const name of preferredNames) {
                            bestVoice = voices.find(v => v.name.includes(name) && v.lang.startsWith('en'));
                            if (bestVoice) break;
                        }
                        
                        // Second try: any en-US voice
                        if (!bestVoice) {
                            bestVoice = voices.find(v => v.lang === 'en-US') || 
                                       voices.find(v => v.lang.startsWith('en')) || 
                                       voices[0];
                        }
                        
                        if (bestVoice) {
                            utterance.voice = bestVoice;
                            console.log('üó£Ô∏è Using voice:', bestVoice.name);
                        }
                        
                        utterance.onstart = () => {
                            this.isSpeaking = true;
                            console.log('‚ñ∂Ô∏è Started speaking at rate:', utterance.rate);
                        };
                        
                        utterance.onend = () => {
                            console.log('‚èπÔ∏è Finished speaking');
                            // Small delay before allowing input again
                            setTimeout(() => {
                                this.isSpeaking = false;
                                console.log('‚úÖ Ready for input');
                            }, 500); // 500ms buffer after speech ends
                            resolve();
                        };
                        
                        utterance.onerror = (event) => {
                            console.error('‚ùå Speech error:', event);
                            this.isSpeaking = false;
                            resolve(); // Resolve anyway to not block
                        };
                        
                        try {
                            this.synthesis.speak(utterance);
                        } catch (error) {
                            console.error('‚ùå Speak error:', error);
                            this.isSpeaking = false;
                            resolve();
                        }
                    }, 100); // 100ms delay helps iOS
                });
            }

            startContinuousListening(onResult) {
                if (!this.recognition) {
                    console.error('Speech recognition not available');
                    return false;
                }

                this.recognition.onresult = (event) => {
                    const last = event.results.length - 1;
                    const transcript = event.results[last][0].transcript.trim();
                    const confidence = event.results[last][0].confidence;
                    console.log('üé§ Heard:', transcript, '(confidence:', confidence, ')');
                    document.getElementById('yourMessage').textContent = `You: "${transcript}"`;
                    
                    // Don't process if caddie is speaking OR if transcript is empty
                    if (!this.isSpeaking && transcript.length > 0) {
                        console.log('‚úÖ Processing command:', transcript);
                        onResult(transcript);
                    } else if (this.isSpeaking) {
                        console.log('‚è∏Ô∏è Caddie is speaking, ignoring input');
                    } else {
                        console.log('‚ö†Ô∏è Empty transcript, ignoring');
                    }
                };

                this.recognition.onerror = (event) => {
                    console.error('üî¥ Recognition error:', event.error);
                    if (event.error === 'not-allowed') {
                        document.getElementById('caddieMessage').textContent = 
                            'Microphone permission needed. Check Settings > Safari > Microphone.';
                        document.getElementById('voiceStatus').textContent = 'üîá Mic permission denied';
                    } else if (event.error === 'no-speech') {
                        console.log('‚ö™ No speech detected, continuing...');
                        return;
                    } else if (event.error === 'aborted') {
                        console.log('‚ö™ Recognition aborted, restarting...');
                    } else {
                        console.log('‚ö†Ô∏è Other error:', event.error, '- attempting restart');
                    }
                };

                this.recognition.onend = () => {
                    console.log('üîµ Recognition ended');
                    if (this.continuousMode) {
                        console.log('üîÑ Auto-restarting recognition...');
                        setTimeout(() => {
                            if (this.continuousMode) {
                                try {
                                    this.recognition.start();
                                    console.log('‚úÖ Recognition restarted');
                                } catch (e) {
                                    if (e.message.includes('already started')) {
                                        console.log('‚ö™ Already running, no restart needed');
                                    } else {
                                        console.error('‚ùå Restart failed:', e.message);
                                    }
                                }
                            }
                        }, 300);
                    }
                };

                this.recognition.onstart = () => {
                    console.log('üü¢ Recognition started');
                };

                try {
                    this.recognition.start();
                    this.continuousMode = true;
                    this.isListening = true;
                    console.log('üéôÔ∏è Continuous listening activated');
                    return true;
                } catch (error) {
                    console.error('‚ùå Could not start continuous listening:', error);
                    return false;
                }
            }

            stopContinuousListening() {
                this.continuousMode = false;
                this.isListening = false;
                if (this.recognition) {
                    this.recognition.stop();
                }
            }

            // Keep the old listen method for backwards compatibility
            listen() {
                return new Promise((resolve, reject) => {
                    if (!this.recognition) {
                        reject('Speech recognition not available');
                        return;
                    }

                    const tempRecognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                    tempRecognition.continuous = false;
                    tempRecognition.interimResults = false;
                    tempRecognition.lang = 'en-US';

                    tempRecognition.onresult = (event) => {
                        const transcript = event.results[0][0].transcript;
                        document.getElementById('yourMessage').textContent = `You: "${transcript}"`;
                        resolve(transcript);
                    };

                    tempRecognition.onerror = (event) => {
                        if (event.error === 'not-allowed') {
                            reject('Microphone access denied. Please allow microphone in your browser settings.');
                        } else if (event.error === 'no-speech') {
                            reject('No speech detected');
                        } else {
                            reject(event.error);
                        }
                    };

                    try {
                        tempRecognition.start();
                    } catch (error) {
                        reject('Could not start listening');
                    }
                });
            }
        }

        // GPS Simulator
        // Real GPS Tracking System
        class GPSTracker {
            constructor() {
                this.currentLocation = null;
                this.pinLocation = null;
                this.lastShotLocation = null;
                this.watchId = null;
                this.isTracking = false;
                this.manualDistance = null; // Verbal distance override
            }

            async requestPermission() {
                if (!('geolocation' in navigator)) {
                    console.error('‚ùå GPS not supported on this device');
                    return false;
                }

                try {
                    // Request location permission
                    const position = await new Promise((resolve, reject) => {
                        navigator.geolocation.getCurrentPosition(resolve, reject, {
                            enableHighAccuracy: true,
                            timeout: 10000,
                            maximumAge: 0
                        });
                    });

                    console.log('‚úÖ GPS permission granted');
                    this.currentLocation = {
                        lat: position.coords.latitude,
                        lon: position.coords.longitude,
                        altitude: position.coords.altitude,
                        accuracy: position.coords.accuracy
                    };
                    return true;
                } catch (error) {
                    console.error('‚ùå GPS permission denied:', error);
                    return false;
                }
            }

            startTracking(onUpdate) {
                if (this.isTracking) return;

                this.watchId = navigator.geolocation.watchPosition(
                    (position) => {
                        this.currentLocation = {
                            lat: position.coords.latitude,
                            lon: position.coords.longitude,
                            altitude: position.coords.altitude,
                            accuracy: position.coords.accuracy
                        };
                        
                        console.log('üìç GPS Update:', this.currentLocation);
                        
                        if (onUpdate) {
                            onUpdate(this.currentLocation);
                        }
                    },
                    (error) => {
                        console.error('‚ö†Ô∏è GPS error:', error.message);
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 5000,
                        maximumAge: 0
                    }
                );

                this.isTracking = true;
                console.log('üõ∞Ô∏è GPS tracking started');
            }

            stopTracking() {
                if (this.watchId !== null) {
                    navigator.geolocation.clearWatch(this.watchId);
                    this.watchId = null;
                    this.isTracking = false;
                    console.log('‚èπÔ∏è GPS tracking stopped');
                }
            }

            setPinLocation(lat, lon) {
                this.pinLocation = { lat, lon };
                console.log('üìç Pin set at:', this.pinLocation);
            }

            getDistance() {
                // Use verbal distance if set (player told us)
                if (this.manualDistance) {
                    return this.manualDistance;
                }
                
                if (!this.currentLocation || !this.pinLocation) {
                    return null; // No distance available
                }

                // Calculate distance to pin in yards
                const distance = this.calculateDistance(
                    this.currentLocation.lat,
                    this.currentLocation.lon,
                    this.pinLocation.lat,
                    this.pinLocation.lon
                );

                return Math.round(distance);
            }

            calculateDistance(lat1, lon1, lat2, lon2) {
                // Haversine formula for distance between two GPS points
                const R = 6371e3; // Earth radius in meters
                const œÜ1 = lat1 * Math.PI / 180;
                const œÜ2 = lat2 * Math.PI / 180;
                const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
                const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

                const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                          Math.cos(œÜ1) * Math.cos(œÜ2) *
                          Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                const meters = R * c;
                const yards = meters * 1.09361; // Convert to yards

                return yards;
            }

            recordShotStart() {
                // Record position before shot
                if (this.currentLocation) {
                    this.lastShotLocation = { ...this.currentLocation };
                    console.log('üì∏ Shot position recorded');
                }
            }

            getLastShotDistance() {
                // Calculate how far the ball traveled
                if (!this.lastShotLocation || !this.currentLocation) {
                    return null;
                }

                const distance = this.calculateDistance(
                    this.lastShotLocation.lat,
                    this.lastShotLocation.lon,
                    this.currentLocation.lat,
                    this.currentLocation.lon
                );

                return Math.round(distance);
            }

            // Compatibility methods for existing code
            moveCloser(yards) {
                // No longer needed with real GPS, but keep for compatibility
                console.log('‚ö†Ô∏è moveCloser called (ignored with real GPS)');
            }

            reset(distance = 385) {
                // Reset pin location (would need user to set new pin)
                this.pinLocation = null;
                this.lastShotLocation = null;
                console.log('üîÑ GPS reset');
            }
        }

        // Main Caddie App
        class CaddieApp {
            constructor() {
                this.storage = new CaddieStorage();
                this.voice = new VoiceCaddie();
                this.gps = new GPSTracker();
                this.vectorPutting = new VectorPuttingCalculator();
                this.ai = new ClaudeAI(); // ü§ñ AI BRAIN!
                this.keepAlive = new KeepAlive(); // üîí Prevent sleep & hold Bluetooth
                this.useAI = true; // Set to false to use old rule-based mode
                this.currentPuttData = {
                    distance: null,
                    slope: null,
                    stimp: 9, // Default medium-fast
                    breakDirection: null,
                    uphillDownhill: 'level'
                };
                this.setupMode = 'initial'; // initial, playing
                this.setupEventListeners();
                this.setupVisibilityHandling();
            }

            setupVisibilityHandling() {
                // Try to keep mic alive even when backgrounded
                // Only pause if fully hidden for extended time
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        console.log('App backgrounded - keeping mic alive if possible');
                        this.backgroundTimer = setTimeout(() => {
                            if (document.hidden && this.voice.continuousMode) {
                                console.log('Still backgrounded after 30s - pausing mic');
                                this.voice.stopContinuousListening();
                                this.wasListeningBeforeBackground = true;
                            }
                        }, 30000);
                    } else {
                        clearTimeout(this.backgroundTimer);
                        console.log('App foregrounded');
                        
                        this.keepAlive.ensureSilentAudio();
                        
                        if (this.wasListeningBeforeBackground) {
                            setTimeout(() => {
                                const started = this.voice.startContinuousListening((text) => {
                                    this.processCommand(text);
                                });
                                if (started) {
                                    document.getElementById('voiceOrb').classList.add('listening');
                                    document.getElementById('voiceStatus').textContent = 'üé§ LIVE - Always listening';
                                }
                                this.wasListeningBeforeBackground = false;
                            }, 500);
                        }
                    }
                });

                // Also handle when app loses focus (iOS-specific)
                window.addEventListener('blur', () => {
                    console.log('App lost focus');
                    if (this.voice.continuousMode) {
                        this.voice.stopContinuousListening();
                        this.wasListeningBeforeBackground = true;
                    }
                });

                window.addEventListener('focus', () => {
                    console.log('App gained focus');
                    if (this.wasListeningBeforeBackground) {
                        setTimeout(() => {
                            const started = this.voice.startContinuousListening((text) => {
                                this.processCommand(text);
                            });
                            if (started) {
                                document.getElementById('voiceOrb').classList.add('listening');
                                document.getElementById('voiceStatus').textContent = 'üé§ LIVE - Always listening';
                            }
                            this.wasListeningBeforeBackground = false;
                        }, 500);
                    }
                });
            }

            setupEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('voiceOrb').addEventListener('click', () => this.handleVoice());
                document.getElementById('statsBtn').addEventListener('click', () => this.speakStats());
                document.getElementById('historyBtn').addEventListener('click', () => this.speakHistory());
                document.getElementById('greenReadBtn').addEventListener('click', () => this.startGreenRead());
                document.getElementById('cameraInput').addEventListener('change', (e) => this.processGreenPhoto(e));
                
                // üéß SHOKZ BUTTON INTEGRATION
                // Tap Shokz button = mute/unmute mic
                if ('mediaSession' in navigator) {
                    console.log('üéß Shokz button integration enabled');
                    
                    try {
                        navigator.mediaSession.setActionHandler('pause', () => {
                            console.log('üéß Shokz PAUSE - Muting mic');
                            this.muteMic();
                        });
                        
                        navigator.mediaSession.setActionHandler('play', () => {
                            console.log('üéß Shokz PLAY - Unmuting mic');
                            this.unmuteMic();
                        });
                        
                        navigator.mediaSession.metadata = new MediaMetadata({
                            title: 'Golf Caddie - Listening',
                            artist: 'AI Assistant',
                            album: 'Round in Progress'
                        });
                    } catch (error) {
                        console.log('‚ö†Ô∏è MediaSession setup error (non-critical):', error.message);
                    }
                }
            }
            
            muteMic() {
                if (this.voice.continuousMode) {
                    this.voice.stopContinuousListening();
                    document.getElementById('voiceStatus').textContent = 'üîá Muted (Tap Shokz or mic to unmute)';
                    document.getElementById('voiceOrb').classList.remove('listening');
                    console.log('üîá Mic muted');
                }
            }
            
            unmuteMic() {
                if (!this.voice.continuousMode) {
                    const started = this.voice.startContinuousListening((text) => {
                        this.processCommand(text);
                    });
                    if (started) {
                        document.getElementById('voiceStatus').textContent = 'üé§ LIVE - Always listening';
                        document.getElementById('voiceOrb').classList.add('listening');
                        console.log('üé§ Mic unmuted');
                    }
                }
            }
            
            toggleMic() {
                if (this.voice.continuousMode) {
                    this.muteMic();
                } else {
                    this.unmuteMic();
                }
            }

            async start() {
                document.getElementById('welcomeScreen').classList.add('hidden');
                document.getElementById('mainApp').style.display = 'flex';
                
                // API key handled by server proxy ‚Äî no prompt needed
                console.log('‚úÖ AI features enabled via server proxy');
                
                // iOS REQUIRES user interaction before speech works
                try {
                    const dummyUtterance = new SpeechSynthesisUtterance(' ');
                    window.speechSynthesis.speak(dummyUtterance);
                    await new Promise(resolve => setTimeout(resolve, 100));
                } catch (error) {
                    console.log('Audio init:', error);
                }
                
                // Request GPS permission
                const gpsGranted = await this.gps.requestPermission();
                if (gpsGranted) {
                    this.gps.startTracking((location) => {
                        this.updateDisplay();
                    });
                }
                
                // Start keep-alive systems (wake lock, Bluetooth audio hold, no-sleep)
                await this.keepAlive.start();
                
                // AI-driven conversational setup
                this.setupMode = 'ai_setup';
                
                // Check if we have clubs configured already
                const hasCustomClubs = this.storage.data.profile.clubDistances['Driver'] !== 250 || 
                                        this.storage.data.profile.clubDistances['7 Iron'] !== 150;
                
                let setupPrompt = '';
                if (hasCustomClubs) {
                    setupPrompt = "Hey, welcome back! I've got your clubs dialed in. What course are we playing today?";
                } else {
                    setupPrompt = "Hey! I'm your caddie. Before we tee off, let's get to know your game. What course are we playing today, and do you want to set up your club distances?";
                }
                
                try {
                    await this.voice.speak(setupPrompt);
                } catch (error) {
                    console.error('Speech error on start:', error);
                    document.getElementById('caddieMessage').textContent = setupPrompt;
                }
                
                // Start continuous listening mode
                const started = this.voice.startContinuousListening((text) => {
                    this.processCommand(text);
                });
                
                if (started) {
                    document.getElementById('voiceOrb').classList.add('listening');
                    document.getElementById('voiceStatus').textContent = 'üé§ LIVE - Always listening';
                } else {
                    await this.voice.speak("Tap the microphone to enable voice control.");
                }
            }

            async handleVoice() {
                this.toggleMic();
            }

            async autoListen() {
                // Not needed in continuous mode - already always listening
            }

            // ==========================================
            // GOLF SPEECH AUTOCORRECT
            // Fixes common speech recognition mistakes for golf terms
            // ==========================================
            golfAutocorrect(text) {
                const corrections = [
                    // Club misheards
                    [/\bforeign\b/gi, '4 iron'],
                    [/\bfor iron\b/gi, '4 iron'],
                    [/\bfore iron\b/gi, '4 iron'],
                    [/\btoo iron\b/gi, '2 iron'],
                    [/\bto iron\b/gi, '2 iron'],
                    [/\bwon iron\b/gi, '1 iron'],
                    [/\bone iron\b/gi, '1 iron'],
                    [/\bthree iron\b/gi, '3 iron'],
                    [/\bfive iron\b/gi, '5 iron'],
                    [/\bsix iron\b/gi, '6 iron'],
                    [/\bseven iron\b/gi, '7 iron'],
                    [/\beight iron\b/gi, '8 iron'],
                    [/\bate iron\b/gi, '8 iron'],
                    [/\bnine iron\b/gi, '9 iron'],
                    [/\bfor hybrid\b/gi, '4 hybrid'],
                    [/\bfore hybrid\b/gi, '4 hybrid'],
                    [/\bfor wood\b/gi, '4 wood'],
                    [/\bfore wood\b/gi, '4 wood'],
                    [/\bthree wood\b/gi, '3 wood'],
                    [/\bfive wood\b/gi, '5 wood'],
                    [/\bseven wood\b/gi, '7 wood'],
                    [/\bnine wood\b/gi, '9 wood'],
                    // Wedge misheards
                    [/\bpitching which\b/gi, 'pitching wedge'],
                    [/\bsand which\b/gi, 'sand wedge'],
                    [/\bsandwich\b/gi, 'sand wedge'],
                    [/\blob which\b/gi, 'lob wedge'],
                    [/\bgap which\b/gi, 'gap wedge'],
                    // Score misheards
                    [/\bbirdie\b/gi, 'birdie'],
                    [/\bbirdy\b/gi, 'birdie'],
                    [/\bboggie\b/gi, 'bogey'],
                    [/\bbogie\b/gi, 'bogey'],
                    [/\bpar three\b/gi, 'par 3'],
                    [/\bpar four\b/gi, 'par 4'],
                    [/\bpar five\b/gi, 'par 5'],
                    // Golf terms
                    [/\bfairway would\b/gi, 'fairway wood'],
                    [/\blay up\b/gi, 'layup'],
                    [/\bstimped\b/gi, 'stimp'],
                    [/\bgreen and regulation\b/gi, 'green in regulation'],
                    // Hole numbers
                    [/\bwhole (\d+)\b/gi, 'hole $1'],
                    [/\bhold (\d+)\b/gi, 'hole $1'],
                ];
                
                let corrected = text;
                for (const [pattern, replacement] of corrections) {
                    corrected = corrected.replace(pattern, replacement);
                }
                
                if (corrected !== text) {
                    console.log(`üî§ Autocorrect: "${text}" ‚Üí "${corrected}"`);
                    document.getElementById('yourMessage').textContent = `You: "${corrected}"`;
                }
                
                return corrected;
            }

            async processCommand(text) {
                // ==========================================
                // GOLF SPEECH AUTOCORRECT
                // Fix common misheard golf terms
                // ==========================================
                text = this.golfAutocorrect(text);
                
                const lower = text.toLowerCase();

                // ==========================================
                // VOICE SPEED - local only, instant response
                // ==========================================
                if (lower.includes('slow down') || lower.includes('slower') || lower.includes('talk slower')) {
                    const currentSpeed = this.storage.data.profile.voiceSpeed || 1.0;
                    const newSpeed = Math.max(0.5, currentSpeed - 0.2);
                    this.storage.data.profile.voiceSpeed = newSpeed;
                    this.storage.save();
                    await this.voice.speak(`Slowing down to ${Math.round(newSpeed * 100)}% speed.`);
                    return;
                }
                if (lower.includes('speed up') || lower.includes('faster') || lower.includes('talk faster')) {
                    const currentSpeed = this.storage.data.profile.voiceSpeed || 1.0;
                    const newSpeed = Math.min(2.0, currentSpeed + 0.2);
                    this.storage.data.profile.voiceSpeed = newSpeed;
                    this.storage.save();
                    await this.voice.speak(`Speeding up to ${Math.round(newSpeed * 100)}% speed.`);
                    return;
                }
                if (lower.includes('normal speed') || lower.includes('regular speed')) {
                    this.storage.data.profile.voiceSpeed = 1.0;
                    this.storage.save();
                    await this.voice.speak(`Back to normal speed.`);
                    return;
                }

                // ==========================================
                // CLUB SETUP MODE - structured input needed
                // ==========================================
                if (this.setupMode === 'club_setup') {
                    const distMatch = text.match(/(\d+)/);
                    if (distMatch) {
                        const distance = parseInt(distMatch[1]);
                        const currentClub = this.clubsToSetup[this.clubSetupIndex];
                        
                        this.storage.data.profile.clubDistances[currentClub] = distance;
                        this.storage.save();
                        
                        this.clubSetupIndex++;
                        
                        if (this.clubSetupIndex < this.clubsToSetup.length) {
                            await this.voice.speak(`${currentClub}, ${distance} yards. How far does your ${this.clubsToSetup[this.clubSetupIndex]} go?`);
                        } else {
                            await this.voice.speak(`Perfect! All clubs configured. Ready to play!`);
                            this.setupMode = 'ai_setup';
                        }
                        return;
                    } else if (lower.includes('skip') || lower.includes('done') || lower.includes('nevermind') || lower.includes('finish')) {
                        await this.voice.speak("Club setup complete!");
                        this.setupMode = 'ai_setup';
                        return;
                    }
                }

                // ==========================================
                // DETECT & STORE: Club distances said naturally
                // "my driver goes 280" / "7 iron is 155"
                // ==========================================
                const clubDistancePattern = /(?:my\s+)?(\w+(?:\s+\w+)?)\s+(?:goes|is|about|around)\s+(\d+)/i;
                const clubDistMatch = text.match(clubDistancePattern);
                if (clubDistMatch) {
                    const detectedClub = this.detectClub(clubDistMatch[1]);
                    const distance = parseInt(clubDistMatch[2]);
                    if (detectedClub && distance >= 40 && distance <= 400) {
                        this.storage.data.profile.clubDistances[detectedClub] = distance;
                        this.storage.save();
                        console.log(`‚úÖ Stored: ${detectedClub} = ${distance} yards`);
                    }
                }

                // Club setup trigger
                if (lower.includes('set up') && lower.includes('club')) {
                    this.setupMode = 'club_setup';
                    this.clubSetupIndex = 0;
                    this.clubsToSetup = ['Driver', '3 Wood', '5 Wood', 'Hybrid', '4 Iron', '5 Iron', '6 Iron', '7 Iron', '8 Iron', '9 Iron', 'Pitching Wedge', 'Gap Wedge', 'Sand Wedge', 'Lob Wedge'];
                    await this.voice.speak(`Okay, let's set up your clubs. How far does your ${this.clubsToSetup[0]} go?`);
                    return;
                }
                
                // End round ‚Äî save to history
                if (lower.includes('end round') || lower.includes('finish round') || lower.includes('done for today')) {
                    const round = this.storage.data.currentRound;
                    if (round && round.holes.length > 0) {
                        this.storage.data.rounds.push({...round});
                        this.storage.data.stats.totalRounds++;
                        this.storage.save();
                        this.ai.generateRoundSummary(round);
                        this.ai.generateMemoryUpdate(this.ai.conversationHistory.slice(-10));
                    }
                }
                
                // ==========================================
                // FAST VECTOR PUTTING ‚Äî instant, no API call
                // "15 feet 2% breaks left to right"
                // "10 feet 3 percent right to left downhill"
                // ==========================================
                const feetMatch = text.match(/(\d+)\s*(?:feet|foot|ft|footer)/i);
                const slopeMatch = text.match(/(\d+)\s*(?:percent|%)/i);
                const hasBreak = lower.includes('left') || lower.includes('right') || lower.includes('straight');
                
                if (feetMatch && (slopeMatch || hasBreak)) {
                    const feet = parseInt(feetMatch[1]);
                    const slope = slopeMatch ? parseInt(slopeMatch[1]) : 2; // default 2%
                    
                    // Detect break direction
                    let breakDir = '';
                    if (lower.includes('left to right') || lower.includes('left-to-right')) {
                        breakDir = 'left-to-right';
                    } else if (lower.includes('right to left') || lower.includes('right-to-left')) {
                        breakDir = 'right-to-left';
                    } else if (lower.includes('breaks left') || lower.includes('break left')) {
                        breakDir = 'right-to-left'; // ball breaks left = aim right
                    } else if (lower.includes('breaks right') || lower.includes('break right')) {
                        breakDir = 'left-to-right'; // ball breaks right = aim left
                    } else if (lower.includes('straight')) {
                        breakDir = 'straight';
                    }
                    
                    // Detect uphill/downhill
                    let elevation = 'level';
                    if (lower.includes('uphill') || lower.includes('up hill')) elevation = 'uphill';
                    if (lower.includes('downhill') || lower.includes('down hill')) elevation = 'downhill';
                    
                    // Get stimp from storage or default
                    const stimp = this.storage.data.profile.stimp || 9;
                    
                    if (breakDir === 'straight') {
                        // Straight putt
                        let advice = `${feet} feet, straight. `;
                        if (elevation === 'uphill') advice += `Uphill ‚Äî hit it firm, 18 inches past.`;
                        else if (elevation === 'downhill') advice += `Downhill ‚Äî soft touch, let gravity work.`;
                        else advice += `Center of the cup. Die it 12 inches past.`;
                        
                        await this.voice.speak(advice);
                    } else if (breakDir) {
                        // Calculate aim point using Vector Putting
                        const aimPoint = this.vectorPutting.getAimPoint(feet, slope, stimp, breakDir, elevation);
                        await this.voice.speak(`${aimPoint.description}. Die it 12 past.`);
                    } else {
                        // Have feet but no break ‚Äî ask for it quickly
                        await this.voice.speak(`${feet} feet, ${slope} percent. Which way does it break?`);
                    }
                    
                    // Track the putt in conversation history for Claude
                    this.ai.conversationHistory.push(
                        { role: 'user', content: text },
                        { role: 'assistant', content: `[Gave putting read for ${feet}ft, ${slope}% slope, ${breakDir || 'unknown break'}]` }
                    );
                    
                    return; // Fast response ‚Äî no API call needed
                }
                
                // Set stimp for the round: "stimp 10" or "greens are 11"
                const stimpMatch = text.match(/stimp\s*(?:is\s*|at\s*|of\s*)?(\d+(?:\.\d+)?)/i) || 
                                   text.match(/greens?\s+(?:are\s+|at\s+)?(\d+(?:\.\d+)?)\s*stimp/i);
                if (stimpMatch) {
                    const stimp = parseFloat(stimpMatch[1]);
                    if (stimp >= 6 && stimp <= 14) {
                        this.storage.data.profile.stimp = stimp;
                        this.storage.save();
                        await this.voice.speak(`Got it, stimp ${stimp}. I'll factor that into all your reads.`);
                        return;
                    }
                }

                // ==========================================
                // EVERYTHING GOES TO AI
                // Claude tracks ALL game data via [DATA] blocks
                // ==========================================
                console.log('ü§ñ Sending to Claude AI:', text);
                
                const currentHole = this.storage.getCurrentHole();
                const courseName = this.storage.data.currentRound?.course;
                const holeNum = currentHole?.number;
                
                const context = {
                    currentHole: currentHole,
                    distance: this.gps.getDistance(),
                    score: this.storage.data.currentRound?.score,
                    course: courseName,
                    holesPlayed: this.storage.data.currentRound?.holes?.length || 0,
                    conditions: currentHole?.conditions,
                    playerClubs: this.storage.data.profile.clubDistances,
                    roundStats: this.storage.getRoundStats(),
                    courseHoleData: courseName && holeNum ? this.storage.getHoleData(courseName, holeNum) : null,
                    courseNotes: courseName && holeNum ? this.storage.getCourseNotes(courseName, holeNum) : [],
                    allCourseHoles: courseName ? this.storage.getCourseData(courseName)?.holes : null,
                    allCourseNotes: courseName ? this.storage.getAllCourseNotes(courseName) : null
                };
                
                try {
                    const result = await this.ai.ask(text, context);
                    
                    // Process game data from Claude's response
                    if (result.gameData) {
                        this.storage.processGameData(result.gameData);
                        this.updateDisplay();
                    }
                    
                    // Speak only the conversational part
                    await this.voice.speak(result.spoken);
                } catch (err) {
                    console.error('AI error:', err);
                    await this.voice.speak("Having trouble connecting. Check your signal.");
                }
            }

            // handleGameCommand removed ‚Äî AI handles all game conversation now

            getAdvancedPuttingAdvice(feet, context = {}) {
                // VECTOR PUTTING METHODOLOGY
                let advice = '';
                
                // First, explain what we're doing (Vector Putting style)
                if (feet <= 3) {
                    advice = `${feet} feet. Using Vector Putting: aim point is inside the cup. Optimal speed - die it 12 inches past if you miss.`;
                } else if (feet <= 5) {
                    advice = `${feet} footer. Vector Putting says aim for optimal terminal velocity - imagine the ball dying 12 inches past the hole.`;
                } else if (feet <= 10) {
                    advice = `${feet} feet. This is a precision putt. Find your Zero Break Line - that's the line straight downhill. Your gravity vector will determine your aim point.`;
                } else if (feet <= 20) {
                    advice = `${feet} feet. Long putt - focus on getting within the 3-foot circle. Speed control is critical here.`;
                } else if (feet <= 40) {
                    advice = `${feet} footer. This is lag putting territory. Visualize a 3-foot circle around the hole. Speed matters more than line.`;
                } else {
                    advice = `Really long, ${feet} feet. Approach putt - just get it inside that 3-foot circle. Don't leave yourself a difficult second putt.`;
                }
                
                // Add slope-specific Vector Putting guidance
                if (context.slope === 'uphill') {
                    advice += " Uphill - the gravity vector works against you. Hit it firmer to maintain optimal terminal velocity.";
                } else if (context.slope === 'downhill') {
                    advice += " Downhill - gravity assists. Less speed needed. Let it die into the hole.";
                }
                
                // Add break context using Zero Break Line concept
                if (context.break === 'left-to-right') {
                    advice += " Breaking left to right - your Zero Break Line is diagonal. Aim point is left of center, let the ball curve down to the hole.";
                } else if (context.break === 'right-to-left') {
                    advice += " Right to left - Zero Break Line runs diagonal the other way. Aim right, trust the gravity vector.";
                }
                
                // Green speed affects everything (Vector Putting principle)
                if (context.speed === 'fast') {
                    advice += " Fast greens - smaller gravity vector. Less break than you think.";
                } else if (context.speed === 'slow') {
                    advice += " Slow greens - larger gravity vector. More break than you expect.";
                }
                
                // Distance-specific Vector Putting wisdom
                if (feet <= 5) {
                    advice += " Remember: optimal terminal velocity is key. Not too fast, not dying at the hole.";
                } else if (feet > 10 && feet <= 25) {
                    advice += " The ball will break more in the final 3 feet as it slows down. Trust your read.";
                }
                
                return advice;
            }

            getLagPuttAdvice(distance) {
                // Vector Putting lag putt philosophy
                if (distance <= 10) {
                    return "Good lag. Vector Putting principle: always aim for 12 inches past. Never up, never in.";
                } else if (distance <= 25) {
                    return "Solid lag putt. In Vector Putting, we think about that 3-foot circle. You're in lag range now.";
                } else {
                    return "Great distance control on that long putt. Vector Putting teaches speed over line on putts this long.";
                }
            }

            detectClub(text) {
                const patterns = [
                    { regex: /\bdriver\b/i, name: 'Driver' },
                    { regex: /\b3\s*wood\b/i, name: '3 Wood' },
                    { regex: /\b5\s*wood\b/i, name: '5 Wood' },
                    { regex: /\bhybrid\b/i, name: 'Hybrid' },
                    { regex: /\b(\d)\s*iron\b/i, match: (m) => `${m[1]} Iron` },
                    { regex: /\bpitching\s*wedge\b|\bpw\b/i, name: 'Pitching Wedge' },
                    { regex: /\bsand\s*wedge\b|\bsw\b/i, name: 'Sand Wedge' },
                    { regex: /\blob\s*wedge\b|\blw\b/i, name: 'Lob Wedge' },
                    { regex: /\bgap\s*wedge\b|\bgw\b/i, name: 'Gap Wedge' },
                    { regex: /\bputter\b/i, name: 'Putter' },
                ];

                for (let p of patterns) {
                    const match = text.match(p.regex);
                    if (match) {
                        return p.match ? p.match(match) : p.name;
                    }
                }
                return null;
            }

            updateDisplay() {
                const round = this.storage.data.currentRound;
                if (round) {
                    document.getElementById('currentHole').textContent = round.currentHole.number;
                    document.getElementById('scoreDisplay').textContent = round.score;
                    document.getElementById('courseInfo').textContent = round.course;
                }
                
                const dist = this.gps.getDistance();
                document.getElementById('distanceDisplay').textContent = dist < 100 ? `${dist}y` : Math.round(dist/10)*10;
            }

            // ==========================================
            // GREEN READ WITH CAMERA
            // ==========================================
            startGreenRead() {
                document.getElementById('cameraInput').click();
            }
            
            async processGreenPhoto(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                // Show processing state
                document.getElementById('caddieMessage').textContent = 'üì∏ Reading the green...';
                document.getElementById('voiceStatus').textContent = 'Analyzing photo';
                
                try {
                    // Resize image to save bandwidth (max 800px)
                    const base64 = await this.resizeAndConvert(file, 800);
                    
                    const currentHole = this.storage.getCurrentHole();
                    const courseName = this.storage.data.currentRound?.course;
                    const holeNum = currentHole?.number;
                    const stimp = this.storage.data.profile.stimp || 9;
                    
                    const context = {
                        stimp: stimp,
                        currentHole: currentHole,
                        course: courseName,
                        courseNotes: courseName && holeNum ? this.storage.getCourseNotes(courseName, holeNum) : []
                    };
                    
                    const result = await this.ai.greenRead(base64, context);
                    
                    // Process any game data (course notes about green shape)
                    if (result.gameData) {
                        this.storage.processGameData(result.gameData);
                        
                        // If Claude returned putting data, run Vector Putting calculator
                        const gd = result.gameData;
                        if (gd.putt_feet && gd.putt_break && gd.putt_break !== 'straight') {
                            const slope = gd.putt_slope || 2;
                            const elevation = gd.putt_elevation || 'level';
                            
                            const aimPoint = this.vectorPutting.getAimPoint(
                                gd.putt_feet, slope, stimp, gd.putt_break, elevation
                            );
                            
                            // Combine Claude's read with Vector Putting math
                            let fullRead = result.spoken;
                            fullRead += ` Vector read: ${aimPoint.description}.`;
                            if (elevation === 'uphill') fullRead += ' Hit it firm, 18 inches past.';
                            else if (elevation === 'downhill') fullRead += ' Soft touch, let gravity do the work.';
                            else fullRead += ' Die it 12 inches past.';
                            
                            await this.voice.speak(fullRead);
                            console.log(`üéØ Vector Putting: ${gd.putt_feet}ft, ${slope}%, ${gd.putt_break}, ${elevation} ‚Üí ${aimPoint.description}`);
                        } else if (gd.putt_feet && gd.putt_break === 'straight') {
                            let fullRead = result.spoken;
                            fullRead += ` Straight putt, center of the cup.`;
                            if (gd.putt_elevation === 'uphill') fullRead += ' Firm, 18 inches past.';
                            else if (gd.putt_elevation === 'downhill') fullRead += ' Easy does it.';
                            else fullRead += ' Die it 12 past.';
                            
                            await this.voice.speak(fullRead);
                        } else {
                            // No putting data extracted, just speak Claude's read
                            await this.voice.speak(result.spoken);
                        }
                    } else {
                        await this.voice.speak(result.spoken);
                    }
                    
                } catch (err) {
                    console.error('Green read error:', err);
                    await this.voice.speak("Couldn't read that photo. Try again or just give me the distance and break.");
                }
                
                // Reset file input so same photo can be retaken
                event.target.value = '';
            }
            
            resizeAndConvert(file, maxSize) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            let w = img.width;
                            let h = img.height;
                            
                            if (w > maxSize || h > maxSize) {
                                if (w > h) {
                                    h = Math.round(h * maxSize / w);
                                    w = maxSize;
                                } else {
                                    w = Math.round(w * maxSize / h);
                                    h = maxSize;
                                }
                            }
                            
                            canvas.width = w;
                            canvas.height = h;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, w, h);
                            
                            // Get base64 without the data:image/jpeg;base64, prefix
                            const dataUrl = canvas.toDataURL('image/jpeg', 0.7);
                            const base64 = dataUrl.split(',')[1];
                            resolve(base64);
                        };
                        img.onerror = reject;
                        img.src = e.target.result;
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            async speakStats() {
                const round = this.storage.data.currentRound;
                if (!round || round.holes.length === 0) {
                    await this.voice.speak("No holes completed yet. Let's get some data first!");
                    return;
                }
                
                const holesPlayed = round.holes.length;
                const totalScore = round.score;
                const par = round.holes.reduce((sum, h) => sum + (h.par || 4), 0);
                const diff = totalScore - par;
                const diffStr = diff === 0 ? 'even par' : diff > 0 ? `${diff} over` : `${Math.abs(diff)} under`;
                
                const rs = this.storage.getRoundStats();
                
                let statsMsg = `Through ${holesPlayed} holes, you're ${diffStr}, ${totalScore} total. `;
                
                if (rs) {
                    if (rs.fairwayAttempts > 0) {
                        statsMsg += `Fairways: ${rs.fairways} of ${rs.fairwayAttempts}. `;
                    }
                    statsMsg += `Greens in regulation: ${rs.girs} of ${holesPlayed}. `;
                    statsMsg += `Total putts: ${rs.totalPutts}, averaging ${(rs.totalPutts / holesPlayed).toFixed(1)} per hole. `;
                    if (rs.upDownAttempts > 0) {
                        statsMsg += `Up and downs: ${rs.upDowns} of ${rs.upDownAttempts}. `;
                    }
                }
                
                // Let AI add a coaching comment
                const result = await this.ai.ask(
                    `Give me a quick one-sentence coaching takeaway based on my stats: ${statsMsg}`,
                    { playerClubs: this.storage.data.profile.clubDistances }
                );
                if (result.spoken) statsMsg += result.spoken;
                
                await this.voice.speak(statsMsg);
            }

            async speakHistory() {
                const rounds = this.storage.data.rounds;
                const currentRound = this.storage.data.currentRound;
                
                if ((!rounds || rounds.length === 0) && !currentRound) {
                    await this.voice.speak("No round history yet. Let's build some data!");
                    return;
                }
                
                let historyMsg = '';
                
                // Recent rounds summary
                const recentRounds = (rounds || []).slice(-5).reverse();
                if (recentRounds.length > 0) {
                    historyMsg += `You've played ${rounds.length} total round${rounds.length > 1 ? 's' : ''}. `;
                    
                    // Calculate averages across rounds
                    let totalScores = 0;
                    let totalHoles = 0;
                    let totalPutts = 0;
                    
                    recentRounds.forEach(round => {
                        const holes = round.holes || [];
                        totalScores += round.score || 0;
                        totalHoles += holes.length;
                        holes.forEach(h => {
                            totalPutts += h.shots ? h.shots.filter(s => s.club === 'Putter').length : 0;
                        });
                    });
                    
                    if (totalHoles > 0) {
                        const avgScore = (totalScores / recentRounds.length).toFixed(0);
                        const avgPutts = (totalPutts / totalHoles).toFixed(1);
                        historyMsg += `Last ${recentRounds.length} rounds: averaging ${avgScore} per round, ${avgPutts} putts per hole. `;
                    }
                    
                    // Last round detail
                    const last = recentRounds[0];
                    const lastDate = new Date(last.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    historyMsg += `Most recent: ${last.course}, ${lastDate}, scored ${last.score} over ${last.holes?.length || '?'} holes. `;
                } else {
                    historyMsg += "No completed rounds yet. ";
                }
                
                // Current round progress
                if (currentRound && currentRound.holes.length > 0) {
                    historyMsg += `Today at ${currentRound.course}: ${currentRound.score} through ${currentRound.holes.length} holes.`;
                }
                
                await this.voice.speak(historyMsg);
            }

            async speakInsights() {
                await this.voice.speak("What would you like to know? Ask me anything about golf, strategy, or Vector Putting.");
            }

            async openSettings() {
                const currentSpeed = this.storage.data.profile.voiceSpeed || 1.0;
                // Show debug info
                const debugInfo = `
Debug Info:
- Voice speed: ${Math.round(currentSpeed * 100)}%
- Speech synthesis: ${!!window.speechSynthesis ? 'Yes' : 'No'}
- Speech recognition: ${!!this.voice.recognition ? 'Yes' : 'No'}
- Continuous mode: ${this.voice.continuousMode ? 'Yes' : 'No'}
- Is listening: ${this.voice.isListening ? 'Yes' : 'No'}
- Is speaking: ${this.voice.isSpeaking ? 'Yes' : 'No'}
- Setup mode: ${this.setupMode}
- Current round: ${this.storage.data.currentRound ? 'Active' : 'None'}

Voice Commands:
- "Slow down" / "Faster"
- "Voice speed 80" (50-200%)
- "Normal speed"

Check console (F12) for logs.
                `.trim();
                
                alert(debugInfo);
                console.log('Full state:', {
                    storage: this.storage.data,
                    voice: this.voice,
                    setupMode: this.setupMode
                });
            }
        }

        // Initialize
        let app;
        document.addEventListener('DOMContentLoaded', () => {
            app = new CaddieApp();
        });
    </script>
</body>
</html>
